#!/bin/bash
# (there may be some bashisms in this script)
#
# This script synchronises the D-I package maintainer's templates
# and translator's translations
#
# Translators, DO NOT RUN THIS SCRIPT YOURSELVES!!!!
#

COMMIT_MARKER="[l10n] [SILENT_COMMIT]"

# Defaults
ONLINE=N
COMMIT=N
KEEP_REVISION=N
FORCE_RUN=N
NUMLEVELS=1
UPDATEPO=Y
SYNCPKGS=Y
QUIET=N
svn=svn
debconfupdatepo=debconf-updatepo

if [ "$DI_L10NSYNC_LOGDIR" ] ; then
	LOG="$DI_L10NSYNC_LOGDIR/l10n-sync.log"
else
	LOG="$(pwd)/l10n-sync.log"
fi

usage() {
echo  "Usage:"
echo  "$0 [--online] [--keep-revision lang] [--atomic] [--atomic-updates] [--commit] [--svn="path_to_svn"] [--debconf-updatepo="debconf-updatepo command"] [--split="split levels"] [--quiet|--nolog] <D-I repository path>"
echo  "    --online            : Work online (will update the local copy on"
echo  "                          the fly)"
echo  "    --commit            : Commit changed files (implies --online)"
echo  "    --force             : Forced run even if 'run=0'"
echo  "                          appears in packages/po/run-l10n-sync"
echo  "                          Should only be used in manual runs"
echo  "    --noupdatepo        : Do not run debconf-updatepo for each package"
echo  "    --nosyncpkgs        : Do not sync PO files for each package"
echo  "    --keep-revision     : Force keeping the old PO-Revision-Date"
echo  "                          for a given language"
echo  "                          meant for use when switching a language"
echo  "                          NOT RECOMMENDED in other situations"
echo  "    --svn               : path to the svn binary"
echo  "    --split             : number of levels for splitted file"
echo  "                          (0 for no split)"
echo  "    --debconf-updatepo  : debconf-updatepo command line"
echo  "                          (for using hacked debconf-updatepo)"
echo  "    --merge="other_dir" : merge master files from master files"
echo  "                          in another directory"
echo  "    --quiet             : don't display progress info, only errors"
echo  "    --nolog             : output all messages to stdout instead of"
echo  "                          the log file"
echo  " <D-I repository path>: path to the local copy of the D-I repository"
}

svnerr() {
echo "Error in a SVN operation, please investigate"
echo "Trying to cleanup locks..."
if "$DI_COPY" ;  then
	cd $DI_COPY
	$svn cleanup
fi
exit 1
}

# Syntax: log_cmd [-m|-p "<message>"] command <arguments>
# Note that any quotes in the <arguments> must be escaped to preserve them.
#
# Unless --nolog was passed, all output of the command will be redirected
# to the log file.
# If the -m or -p option is used, a progress message is be printed when the
# command is executed. With -m just the message will be printed, with -p the
# result of the command will be printed after the message (only on stdout).
# Use the --pass option if output of the command is redirected; because of
# this option messages are redirected to stderr.
log_cmd() {
	local progress message redir
	if [ "$1" = "--pass" ] ; then
		redir="$REDIRERR"
		shift
	else
		redir="$REDIR"
	fi

	progress=""
	if [ "$1" = -m ] || [ "$1" = -p ] ; then
		if [ "$1" = -p ] && [ "$LOG" ] ; then
			progress=1
		fi
		message="$2"
		shift 2
	fi

	if [ "$message" ] ; then
		if [ "$QUIET" = N ] ; then
			[ "$progress" ] && echo -n "$message" >&2 || echo "$message" >&2
		fi
		[ -z "$LOG" ] || echo "$message" >>$LOG
	fi

	RET=0
	eval "$@" $redir || RET=$?

	if [ "$progress" ] && [ "$QUIET" = N ] ; then
		[ $RET -eq 0 ] && echo " done." >&2 || echo " failed." >&2
	fi
	return $RET
}

log() {
	[ "$QUIET" = Y ] || echo "$1"
	[ -z "$LOG" ] || echo "$1" >>$LOG
}

# Log without newline
logn() {
	[ "$QUIET" = Y ] || echo -n "$1"
	[ -z "$LOG" ] || echo -n "$1" >>$LOG
}

# Special logging
log_s1() {
	if [ "$LOG" ] ; then
		[ "$QUIET" = Y ] || echo -n "($2) "
		echo "$1 $2" >>$LOG
	else
		echo "$1 $2"
	fi
}

error() {
	echo "$1" >&2
	[ -z "$LOG" ] || echo "$1" >>$LOG
}

gettexterr() {
	error "Error in a gettext operation, please investigate"
	error "Lock file NOT removed"
	exit 2
}

criticalerr() {
	error "Critical error during run, please investigate"
	error "Lock file NOT removed"
	exit 3
}

##  Command line parsing
MORETODO=true
while $MORETODO ; do
	case "$1" in
	"--online")
		ONLINE=Y
		;;
	"--keep-revision"*)
		KEEP_REVISION=`echo $1|cut -f2 -d=`
		if [ -z "$KEEP_REVISION" ] ; then
			usage
			exit 1
		fi
		;;
	"--commit")
		COMMIT=Y
		;;
	"--force")
		FORCE_RUN=Y
		;;
	"--noupdatepo")
		UPDATEPO=N
		;;
	"--nosyncpkgs")
		SYNCPKGS=N
		;;
	"--merge="*)
		MERGEDIR=`echo $1|cut -f2 -d=`
		;;
	"--svn="*)
		svn=`echo $1|cut -f2 -d=`
		;;
	"--split="*)
		NUMLEVELS=`echo $1|cut -f2 -d=`
		;;
	"--debconf-updatepo="*)
		debconfupdatepo=`echo $1|cut -f2 -d=`
		;;
	"--quiet")
		QUIET=Y
		;;
	"--nolog")
		LOG=""
		;;
	"--"*)
		echo "Illegal option: $1" >&2
		usage
		exit 1
		;;
	*)
		DI_COPY=$1
		MORETODO=false
		;;
	esac
	shift
done

if [ -z "$DI_COPY" ] ; then
	usage
	exit 1
fi

REDIR=""
REDIRERR=""
if [ "$LOG" ] ; then
	if ! touch $LOG 2>/dev/null ; then
		echo "Cannot write to log file '$LOG'" >&2
		exit 1
	fi
	> $LOG
	REDIR=">>$LOG 2>&1"	
	REDIRERR="2>>$LOG"	
else
	# Ensure output goes at least somewhere
	QUIET=N
fi

if [ "$NUMLEVELS" -gt 9 ] ; then
	error "Maximum of 9 sublevels supported"
	exit 1
elif [ "$NUMLEVELS" -gt 1 ] ; then
	WITHLEVELS=Y
	LEVELS=`seq 1 $NUMLEVELS`
else
	# If NUMLEVELS<=1 we use the old way (no levels)
	WITHLEVELS=N
	LEVELS=1
fi

# If we asked for commits we are online...:-)
if [ "$COMMIT" = "Y" ] ; then
	ONLINE=Y
fi


# A few checks about the D-I copy directory
if [ ! -d $DI_COPY ] ; then
	error "$DI_COPY does not exist"
	exit 1
fi

if [ ! -d $DI_COPY/packages/.svn ] ; then
	error "No $DI_COPY/packages/.svn directory found"
	error "$DI_COPY may not be a copy of Debian Installer SVN repository"
	exit 1
fi

if ! grep -q "/d-i/" $DI_COPY/packages/.svn/entries ; then
	error "$DI_COPY does not seem to be a complete Debian Installer SVN copy"
	error "Please check it"
	exit 1
fi

if [ -n "$MERGEDIR" ] ; then
	if [ ! -d "$MERGEDIR" ] ; then
		error "$MERGEDIR is not a directory"
		exit 1
	elif [ ! -d "$MERGEDIR/packages/po" ] ; then
		error "$MERGEDIR/packages/po does not exist; please check that"
		error "$MERGEDIR is a complete local Debian Installer repository"
		exit 1
	fi   
fi

# Check that utilities we need are available
for i in msgcat msgmerge msgattrib `echo ${debconfupdatepo} | awk '{print $1};'` ; do
	if ! which $i >/dev/null 2>&1 ; then
		error "$i not found in the PATH"
		exit 1
	fi
done

# Do not accept working on an unclean copy
if $(svn st $DI_COPY/packages | grep -q "^C") ; then
	error "$DI_COPY seems to contain some SVN conflict files"
	error "Please fix this before launching the script again"
	exit 1
fi

### From here we start the real work
log "Starting l10n-sync run - $(date -u)"

# First, update the packages/po directory
# to get the run-l10n-sync file
cd $DI_COPY/packages/po
if [ "$ONLINE" = "Y" ] ; then
	log_cmd -p "Synchronize $DI_COPY/packages..." \
		$svn update || svnerr
fi

# Check the packages/po/run-l10n-sync file
markerfile=${DI_COPY}/packages/po/run-l10n-sync
if [ -f ${markerfile} ] ; then
	. ${markerfile}
	if [ -n "${run}" ] ; then
		if [ ${run} = 0 ] ; then
			if [ "${FORCE_RUN}" = "Y" ] ; then
				log "Enforce running despite instruction in ${markerfile}"
			else
				log "Explicit request to not run the script in ${markerfile}"
				exit 0
			fi
		fi
	fi
else
	error "No ${markerfile} file: aborting"
	exit 1
fi
log ""

# Check the packages/po/packages_list* files
listfile=${DI_COPY}/packages/po/packages_list

# Do not accept working on a locked copy
LOCKFILE=$DI_COPY/.l10n.lock
if [ -f $LOCKFILE ] ; then
	error "$LOCKFILE file detected"
	error "$DI_COPY seems to be locked by another l10n process"
	error "Please fix this before lauching the script again"
	exit 1
else
	touch $LOCKFILE
fi

# First, update the copy of D-I repository
cd $DI_COPY/packages
if [ "$ONLINE" = "Y" ] ; then
	log_cmd -p "Synchronize $DI_COPY/packages..." \
		$svn update || svnerr
fi

# In case a merge has to be done with another directory
# we update this directory as well
if [ -n "$MERGEDIR" ] ; then
	cd $MERGEDIR/packages/po
	if [ "$ONLINE" = "Y" ] ; then
		log_cmd -p "Synchronize the merge directory $MERGEDIR/packages/po..." \
			$svn update || svnerr
	fi
fi

# Let's check the thing again....ceinture et bretelles as we say in French
if $(svn st $DI_COPY/packages | grep -q "^C") ; then
	error "$DI_COPY seems to contain some SVN conflict files"
	error "Please fix this before lauching the script again"
	exit 1
fi

# Build a list of all D-I packages with i18n material
# The list of packages is taken from the file
# "packages_list" maintained in packages/po
packages=$(grep -v -E "^\#|^[[:space:]]*$" ${listfile})

pots=''
for package in $packages ; do
	pots="$pots ${package}/debian/po/templates.pot"
done

# Loop over packages
#  1a) sync the debian/ directory
#  1b) run debconf-updatepo
#  1c) commit back the changes
log "Phase I: run debconf-updatepo for all packages"
if [ "$UPDATEPO" = "Y" ]; then

	for i in  $packages; do 
		log "- $i"
		cd $DI_COPY/packages/$i/debian
		cd $DI_COPY/packages/$i/debian
		log_cmd -p "  - Run debconf-updatepo..." \
			$debconfupdatepo
	done
	if [ "$COMMIT" = "Y" ] ; then
		cd $DI_COPY/packages
		log_cmd -p "  - Commit changes to SVN..." \
			$svn commit -m \"$COMMIT_MARKER Run debconf-updatepo on all packages\" || svnerr
	fi

else
	log "- Not running debconf-updatepo for packages as requested"
fi
log ""

# 2) Merge all templates.pot files together
cd $DI_COPY/packages
log "Phase II: update master tempate files"

# First we create the overall template.pot file
log "- Merge all package templates.pot files..."
# Check that the next msgcat will not fail (otherwise the template.pot would be empty!)
if ! msgcat ${pots} >/dev/null 2>&1 ; then
	svnerr
fi
log_cmd --pass 	msgcat ${pots} | \
	sed 's/charset=CHARSET/charset=UTF-8/g' >$DI_COPY/packages/po/template.pot.new
# Determine the most recent POT-Creation-Date for individual components
# Include master templates.pot too so the timestamp will never be set back
LASTDATE="$(
	for j in ${pots} po/template.pot; do
		date -ud "$(grep "POT-Creation-Date:" $j | sed 's/^.*: \(.*\)\\n.*$/\1/')" "+%F %R%z"
	done | sort | tail -n 1)"
# We don't want all templates.pot files headers as we don't care about them
# So we merge the generated file with a simple header.pot file
if [ -f po/header.pot -a -s po/template.pot.new ] ; then
	msgcat --use-first po/header.pot po/template.pot.new | \
		sed 's/charset=UTF-8/charset=CHARSET/g' | \
		sed "s/^.*POT-Creation-Date:.*$/\"POT-Creation-Date: $LASTDATE\\\n\"/" \
		> po/template.pot
	rm po/template.pot.new
else
	error "ERROR: no $DI_COPY/packages/po/header.pot file. Cannot continue."
	exit 1
fi

# Now we create template.pot files for the sublevels
# OK, should be a nice loop...:-)
if [ "$WITHLEVELS" = "Y" ] ; then
	# Temporarily restore charset header
	sed -i 's/charset=CHARSET/charset=UTF-8/g' ${DI_COPY}/packages/po/template.pot
	# Sanity check: template.pot should not contain incorrect sublevels
	if [ "$(msggrep -X -E -e ":sl([^1-$NUMLEVELS]|..+):" \
	   	${DI_COPY}/packages/po/template.pot)" ]; then
		error "Invalid sublevel comments detected in template.pot"
		exit 1
	fi
	for i in $LEVELS; do
		dir=po/sublevel$i
		# Sanity check
		if [ ! -d ${DI_COPY}/packages/po/sublevel$i ]; then
			error "Error: directory for sublevel$i does not exist"
			exit 1
		fi
		level="sublevel $i "
		log "- Create the ${level}template.pot file..."
		if [ $i -eq 1 ]; then
			# Select strings without a level
			# NOTE: this will fail in the case where a string exists in
			# more than one package POT file and has no level set in one
			# of them, but does have it set in others! The string will
			# then end up in the highest level that is explicitly set.
			msggrep -X -E -v -e ":sl[1-$NUMLEVELS]:" ${DI_COPY}/packages/po/template.pot >${DI_COPY}/packages/${dir}/template.pot.none
			# Select strings with level 1 set
			msggrep -X -E -e ":sl1:" ${DI_COPY}/packages/po/template.pot >${DI_COPY}/packages/${dir}/template.pot.sl1
			# Merge them
			msgcat ${DI_COPY}/packages/${dir}/template.pot.none ${DI_COPY}/packages/${dir}/template.pot.sl1 >${DI_COPY}/packages/${dir}/template.pot
			rm ${DI_COPY}/packages/${dir}/template.pot.none ${DI_COPY}/packages/${dir}/template.pot.sl1
		else
			# Select strings with level N set, but exclude any strings that
			# also have a level smaller than N set to avoid duplicates
			msggrep -X -E -e ":sl$i:" ${DI_COPY}/packages/po/template.pot | \
				msggrep -X -E -v -e ":sl[1-$(($i - 1))]:" \
				>${DI_COPY}/packages/${dir}/template.pot
		fi
		sed -i 's/charset=UTF-8/charset=CHARSET/g' ${DI_COPY}/packages/${dir}/template.pot
	done
	# Reset the charset header again
	sed -i 's/charset=UTF-8/charset=CHARSET/g' ${DI_COPY}/packages/po/template.pot
fi
log ""

# For each PO file in packages/po/sublevel* or packages/po:
# 3a) Synchronize with D-I SVN
# 3b) Update with template.pot
# 3c) Grab translations from the lower levels file(s)
# 3d) commit back the changed file
log "Phase III: update master translation files"
for i in $LEVELS; do
	if [ "$WITHLEVELS" = "Y" ] ; then
		dir=po/sublevel$i
		level="level $i "
	else
		dir=po
		level=""
	fi
	log "- Update ${level}PO files"
	cd $DI_COPY/packages/$dir
	# The languages variable will contain the list of *supported* languages.
	# Supported languages will have PO files content spread over D-I packages.
	# Other languages will only have a PO file in packages/po.
	#
	# This allows us to have prospective translations that do not clutter
	# up all packages. Any languages without supported locale in Debian
	# should remain in the list of PROSPECTIVE languages.

	alllanguages=$(ls -1 *.po | sed 's/\.po//g')
	languages=""
	if [ -f $DI_COPY/packages/po/PROSPECTIVE ] ; then
		for language in $alllanguages ; do
			if ! grep -q -e "^${language}$" $DI_COPY/packages/po/PROSPECTIVE ; then
				languages="$languages $language"
			fi
		done
	else
		languages=$alllanguages
	fi
	
	for po in *.po ; do
		lang=$(basename $po .po)
		log "- $lang"
		if [ "$ONLINE" = "Y" ] ; then
			log_cmd -p "  - Update from SVN..." \
				$svn update || svnerr
		fi
		if [ -n "$MERGEDIR" ] ; then
			log "  - Merge with $MERGEDIR/packages/$dir/$lang.po"
			if [ -f "$MERGEDIR/packages/$dir/$lang.po" ] ; then
				if [ -f $po ]; then
					if ! msgcat --use-first "$MERGEDIR/packages/$dir/$lang.po" $po >$po.new ; then
						gettexterr
					fi
					mv $po.new $po
				fi
			fi
		fi
		if [ "$i" -gt 1 ]; then
			log "     - Merge with other levels"
			previous=`expr $i - 1`
			for j in `seq 1 $previous`; do
				log " $j"
				if [ -f $po -a -f ../sublevel$j/$po ]; then
					msgcat --use-first ../sublevel$j/$po $po >$po.new
					mv $po.new $po
				fi
			done
		fi
		log_cmd --pass -m "  - Merge with template.pot" \
			msgmerge --previous $po template.pot >$po.new || gettexterr
		msgattrib --width=79 --no-obsolete $po.new >$po
		rm $po.new
	done
	if [ "$COMMIT" = "Y" ] ; then
		log_cmd -p "- Commit all general PO files to SVN..." \
			$svn commit -m \"$COMMIT_MARKER Updated packages/$dir/* with general template.pot\" *.po template.pot || svnerr
	fi
done

# If we use levels, create a temporary general file
# (which we won't commit) to make merging in individual packages
# much faster
if [ "$WITHLEVELS" = "Y" ] ; then
	cd $DI_COPY/packages/po
	for po in sublevel1/*.po ; do
		lang=$(basename $po .po)
		list=""
		for i in `seq $NUMLEVELS -1 1`; do
			if [ -f sublevel${i}/${lang}.po ]; then
				list="$list sublevel${i}/${lang}.po"
			fi
		done
		msgcat --use-first $list >${lang}.po
	done
fi
log ""

# Loop over D-I packages:
# 4a) synchronize the local copy with the D-I SVN 
# 4b) update debian/po/*.po files with files in packages/po/
# 4c) commit back the changes to D-I SVN
log "Phase IV: update translations for D-I packages"
if [ "$SYNCPKGS" = "Y" ]; then
	
	for package in $packages ; do
		log "- $package"
		cd $DI_COPY/packages/$package/debian/po
		if [ "$ONLINE" = "Y" ] ; then
			log_cmd -p "  - synchronize with D-I repository..." \
				$svn update || svnerr
		fi
		log "  - rebuild language files"
		# For each language listed in packages/po, update PO files
		for lang in $languages ; do
			logn "$lang "
			cat >$lang.po.new <<EOF
# THIS FILE IS AUTOMATICALLY GENERATED FROM THE MASTER FILE:
# packages/po/$lang.po
#
# DO NOT MODIFY IT DIRECTLY: SUCH CHANGES WILL BE LOST
#
EOF
			log_cmd --pass msgmerge $DI_COPY/packages/po/$lang.po templates.pot | \
				msgattrib --width=79 --no-obsolete - >>$lang.po.new
			if [ -f $lang.po ] ; then
				# We change PO-Revision-Date in the new file only if 
				# the changes are more than just changing a header
				# or comment line. For this we "filter" the files
				# using a carefully crafted regexp.
				# Comment lines (^\#.*$) are filtered, EXCEPT for
				# the fuzzy markers (^\#,.*$).
				oldfiltered=`tempfile`
				newfiltered=`tempfile`
				filter="^(\"(PO-Revision-Date|Project-Id-Version|Report-Msgid-Bugs-To|POT-Creation-Date|Last-Translator|Language-Team|Plural-Forms|X-.*):|#[^,]|#$)"
				egrep -v "$filter" $lang.po >$oldfiltered
				egrep -v "$filter" $lang.po.new >$newfiltered
				if [ -z "$(diff $oldfiltered $newfiltered)" ] ; then
					# Don't commit if the only chages are in filtered lines
					rm $lang.po.new
				else
					# At least one unfiltered line changed
					# Put the old Revision-Date back if asked for
					if [ "$KEEP_REVISION" != "N" ] && [ "$KEEP_REVISION" = "$lang" ] ; then
						# Grab back the PO-Revision-Date from the old file
						old_revision=`grep -e "^\"PO-Revision-Date:" $lang.po | sed 's/\\\\n\"//g'`
						# And replace the one from the new file with it
						# then put all this as a result
						sed "s/\"PO-Revision-Date:.*/$old_revision\\\\n\"/g" $lang.po.new >$lang.po
						rm $lang.po.new
						log_s1 "${package}/debian/po/${lang}.po" "CHANGED, revision kept"
					else
						mv $lang.po.new $lang.po
						log_s1 "${package}/debian/po/${lang}.po" "CHANGED"
					fi
				fi
				# Remove temporary files
				rm -f $oldfiltered
				rm -f $newfiltered
			else
				mv $lang.po.new $lang.po
				svn add $lang.po
				log_s1 "${package}/debian/po/${lang}.po" "ADDED"
			fi
		done
		log ""
	done
	
	if [ "$COMMIT" = "Y" ] ; then
		cd $DI_COPY/packages
		log_cmd -p "Commit changes to SVN..." \
			svn commit -m \"$COMMIT_MARKER Synchronising with translation files from packages/po\" || svnerr
	fi
else
	log "- Not syncing D-I packages as requested"
fi

log "Run successfully completed - $(date -u)"
# Remove the lock file
rm -f $LOCKFILE || true
