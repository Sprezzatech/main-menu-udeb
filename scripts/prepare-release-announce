#!/usr/bin/perl -w
# © 2012 Cyril Brulebois <kibi@debian.org>
#
# Take two debian-installer versions as parameters, get the build logs
# on all relevant architectures, and compare the packages. From there,
# display removed/added packages, as well as updated packages.
#
# Example:
#
#   ./prepare-release-announce         \
#     --old-linux-abi 3.2.0-2          \
#     --new-linux-abi 3.2.0-3          \
#     --old-linux-arch '(486|686-pae)' \
#     --new-linux-arch 'amd64'         \

use strict;
use File::Temp qw(tempdir);
use Text::TabularDisplay;
use Dpkg::Version;
use Getopt::Long;

my $workdir = 'release-announce.tmp';
my $old_linux_abi;
my $new_linux_abi;
my $old_linux_arch;
my $new_linux_arch;

GetOptions(
    'workdir=s'        => \$workdir,
    'old-linux-abi=s'  => \$old_linux_abi,
    'new-linux-abi=s'  => \$new_linux_abi,
    'old-linux-arch=s' => \$old_linux_arch,
    'new-linux-arch=s' => \$new_linux_arch,
);

my ($old, $new) = @ARGV;

die "Usage: $0 old-release-date new-release-date\n"
    if not $old or not $new;

die "old-release-date ($old) should be less than new-release-date ($new)"
    if $old ge $new;

sub sep() { print "\n"; }

# FIXME: This is an awful way to determine release architectures.
my $ra = `rmadison -s testing bash`;
chomp $ra;
$ra =~ s/^.* \| //;
my @ra = split ', ', $ra;
print STDERR "DEBUG: ra: @ra\n";
print STDERR "DEBUG: workdir: $workdir\n";

my $source = 'debian-installer';
my $status;
my @archs;
for my $v ($old, $new) {
    for my $a (@ra) {
        # Skip source…
        next if $a eq 'source';

        # One can't use the return code for now (#681779):
        # FIXME: Change behaviour to support incremental runs:
#        `cd $workdir && getbuildlog $source $v $a >/dev/null 2>&1`;
        my $filename = "$workdir/${source}_${v}_${a}.log";
        $status->{$v}->{$a} = (-f $filename ? "$filename" : undef);
        push @archs, $a;
    }
}

# Uniquify:
my %seen = ();
@archs = grep { ! $seen{$_}++ } @archs;

# Avoid long arch names:
s/^kfreebsd-/kf-/ for (@archs);
s/^powerpc/ppc/   for (@archs);

# Build table for information only:
my $tb = Text::TabularDisplay->new('', @archs);

# Package versions:
my %versions;
for my $v (sort keys %{$status}) {
    my @tb_line = ("$v");
    for my $a (sort keys %{$status->{$v}}) {
        push @tb_line, ($status->{$v}->{$a} ? '********' : ' no log ');
        if ($status->{$v}->{$a}) {
            open my $log, '<', $status->{$v}->{$a}
                or die "Unable to open log file $status->{$v}->{$a}";
            while (my $line = <$log>) {
                next if $line !~ /^Get:/;
                next if $line =~ /\b(?:InRelease|Sources|Packages|TranslationIndex|Release\.gpg|Release)\b/;
                next if $line =~ /\(dsc|tar\)/;
                next if $line =~ /\bTranslation-/;

                # Funnily the arch doesn't appear when fetching from incoming:
                my ($package, $arch, $version);
                if ($line =~ /http:\/\/incoming.debian.org.*?(\S+)\s+(\S+)\s+\[.*?\]$/) {
                    ($package, $version) = ($1, $2);
                }
                elsif ($line =~ /(\S+)\s+(\S+)\s+(\S+)\s+\[.*?\]$/) {
                    ($package, $arch, $version) = ($1, $2, $3);
                }
                else {
                    die "oops, unable to parse $line";
                }

                # FIXME: Decide whether not caring about binNMUs is ok:
                $version =~ s/\+b\d+$//;

                #print "$package $arch $version detected\n";
                my $which = $v eq $old ? 'old' : 'new';
                if (not defined $versions{$package}{$which}) {
                    $versions{$package}{$which} = $version;
                }
                elsif ($versions{$package}{$which} ne $version) {
                    $versions{$package}{$which} = $version
                        if $which eq 'old' && version_compare($versions{$package}{$which}, $version) >= 0;
                    $versions{$package}{$which} = $version
                        if $which eq 'new' && version_compare($versions{$package}{$which}, $version) <= 0;
                }
            }

            close $log
                or die "Unable to close log file $status->{$v}->{$a}";
        }
    }
    $tb->add( @tb_line );
}

print $tb->render, "\n";
sep;

# Diff old/new to build updated/removed/added lists:
my $vtb = Text::TabularDisplay->new('Updated package', 'Old version', 'New version');
my (@added, @removed);
foreach my $package (sort keys %versions) {
  if ($versions{$package}{'old'} &&
      $versions{$package}{'new'} &&
      $versions{$package}{'old'} ne $versions{$package}{'new'}) {
    $vtb->add( $package, $versions{$package}{'old'}, $versions{$package}{'new'} );
    print STDERR $package, " ", $versions{$package}{'old'}, " ", $versions{$package}{'new'}, "\n";
  }
  if ($versions{$package}{'old'} &&
      not $versions{$package}{'new'}) {
    push @removed, $package;
  }
  if ($versions{$package}{'new'} &&
      not $versions{$package}{'old'}) {
    push @added, $package;
  }
}

# Try and detect renamed packages, based on a linux ABI bump:
if ($old_linux_abi and $new_linux_abi) {
    # @renamed isn't actually used later, but keeping it around
    # doesn't hurt. Can be useful for later debugging.
    my @renamed;
    my @maybe_renamed = @removed;
    foreach my $p (@maybe_renamed) {
        if ($p =~ /-${old_linux_abi}-/) {
            my $rp = $p;
            $rp =~ s/-${old_linux_abi}-/-${new_linux_abi}-/;
            if (grep { $_ eq $rp } @added) {
                @removed = grep { $_ ne $p } @removed;
                @added = grep { $_ ne $rp } @added;
                push @renamed, "$p → $rp";
            }
        }
    }

    # Additionally, if archs for the maintainer uploads were
    # different, massage a bit more:
    if ($old_linux_arch and $new_linux_arch) {
        @removed = grep { $_ !~ /-${old_linux_abi}-${old_linux_arch}-/ } @removed;
        @removed = grep { $_ !~ /-${old_linux_abi}-${new_linux_arch}-/ } @removed;
        @added   = grep { $_ !~ /-${new_linux_abi}-${new_linux_arch}-/ } @added;
        @added   = grep { $_ !~ /-${new_linux_abi}-${old_linux_arch}-/ } @added;
    }
}

print $vtb->render, "\n";
sep;

my $removed_tb = Text::TabularDisplay->new("Removed package", "Version");
foreach my $p (@removed) {$removed_tb->add($p, $versions{$p}{old});}
print $removed_tb->render, "\n";
sep;

my $added_tb = Text::TabularDisplay->new("Added package", "Version");
foreach my $p (@added) {$added_tb->add($p, $versions{$p}{new});}
print $added_tb->render, "\n";
