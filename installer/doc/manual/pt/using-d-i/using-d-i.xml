<!-- Start of file using-d-i/using-d-i.xml -->
<!-- $Id: using-d-i.xml 19074 2004-08-15 12:59:43Z fjpop-guest $ -->


 <chapter id="d-i-intro"><title>Using the Debian Installer</title>

 <sect1><title>How the Installer Works</title>
<para>

The Debian Installer consists of a number of special-purpose
components to perform each installation task. Each component performs
its task, asking the user questions as necessary to do its job.
The questions themselves are given priorities, and the priority
of questions to be asked is set when the installer is started.

</para><para>

When a default installation is performed, only essential (high priority)
questions will be asked. This results in a highly automated installation
process with little user interaction. Components are automatically run
in sequence; which components are run depends mainly on the installation
method you use and on your hardware. The installer will use default values
for questions that are not asked.

</para><para>

If there is a problem, the user will see an error screen, and the
installer menu may be shown in order to select some alternative
action. If there are no problems, the user will never see the
installer menu, but will simply answer questions for each component
in turn. Serious error notifications are set to priority 'critical'
so the user will always be notified.

</para><para>

Some of the defaults that the installer uses can be influenced by passing
boot arguments when &d-i; is started. If, for example, you wish to
force static network configuration (DHCP is used by default if available),
you could add the boot parameter <userinput>netcfg/disable_dhcp=true</userinput>.
See <xref linkend="installer-args"/> for available options.

</para><para>

Power users may be more comfortable with a menu-driven interface,
where each step is controlled by the user rather than the installer
performing each step automatically in sequence. To use the installer
in a manual, menu-driven way, add the boot argument
<userinput>debconf/priority=medium</userinput>.

</para><para>

If your hardware requires you to pass options to kernel modules as
they are installed, you will need to start the installer in
<quote>expert</quote> mode. This can be done by either using the
<command>expert</command> command to start the installer or by adding
the boot argument <userinput>debconf/priority=low</userinput>.
Expert mode gives you full control over &d-i;.

</para><para>

The normal installer display is character-based (as opposed to the now
more familiar graphical interface). The mouse is not operational in
this environment. Here are the keys you can use to navigate within the
various dialogs.  The <keycap>Tab</keycap> or <keycap>right</keycap>
arrow keys move `forward', and the <keycombo> <keycap>Shift</keycap>
<keycap>Tab</keycap> </keycombo> or <keycap>left</keycap> arrow keys
move `backward' between displayed buttons and selections.
The <keycap>up</keycap> and <keycap>down</keycap> arrow select
different items within a scrollable list, and also scroll the list
itself. In addition, in long lists, you can type a letter to cause the
list to scroll directly to the section with items starting with the
letter you typed and use <keycap>Pg-Up</keycap> and
<keycap>Pg-Down</keycap> to scroll the list in sections.  The
<keycap>space bar</keycap> selects an item such as a checkbox.  Use
&enterkey; to activate choices.

</para><para arch="s390">

S/390 does not support virtual consoles. You may open a second and third
ssh session to view the logs described below.

</para><para>

Error messages are redirected to the third console.
You can access this console by
pressing <keycombo><keycap>Left Alt</keycap><keycap>F3</keycap></keycombo>
(hold the left <keycap>Alt</keycap> key while pressing the
<keycap>F3</keycap> function key); get back to
the main installer process with 
<keycombo><keycap>Left Alt</keycap><keycap>F1</keycap></keycombo>.

</para><para>

These messages can also be found in
<filename>/var/log/messages</filename>.  After installation, this log
is copied to <filename>/var/log/debian-installer/messages</filename> on your
new system. Other installation messages may be found in
<filename>/var/log/</filename> during the
installation, and <filename>/var/log/debian-installer/</filename>
after the computer has been booted into the installed system.

</para>
 </sect1>


  <sect1 id="modules-list"><title>Components Introduction</title>
<para>

Here is a list of installer components with a brief description
of each component's purpose. Details you might need to know about
using a particular component are in <xref linkend="module-details"/>.

</para>

<variablelist>
<varlistentry>

<term>main-menu</term><listitem><para>

Shows the list of components to the user during installer operation,
and starts a component when it is selected. Main-menu's
questions are set to priority medium, so if your priority is set to
high or critical (high is the default), you will not see the menu. On
the other hand, if there is an error which requires your intervention,
the question priority may be downgraded temporarily to allow you
to resolve the problem, and in that case the menu may appear.

</para><para>

You can get to the main menu by selecting the "Back" button
repeatedly to back all the way out of the currently running component.

</para></listitem>
</varlistentry>
<varlistentry>

<term>languagechooser</term><listitem><para>

Shows a list of languages and language variants. The installer will
display messages in the chosen language, unless the translation for
that language is not complete. When a translation is not complete,
English messages are shown.

</para></listitem>
</varlistentry>
<varlistentry>

<term>countrychooser</term><listitem><para>

Shows a list of countries. The user may choose the country he lives
in.

</para></listitem>
</varlistentry>
<varlistentry>

<term>kbd-chooser</term><listitem><para>

Shows a list of keyboards, from which the user chooses the model which
matches his own.

</para></listitem>
</varlistentry>
<varlistentry>

<term>hw-detect</term><listitem><para>

Automatically detects most of the system's hardware, including network
cards, disk drives, and PCMCIA.

</para></listitem>
</varlistentry>
<varlistentry>

<term>cdrom-detect</term><listitem><para>

Looks for and mounts a Debian installation CD.

</para></listitem>
</varlistentry>
<varlistentry>

<term>netcfg</term><listitem><para>

Configures the computer's network connections so it can communicate
over the internet.

</para></listitem>
</varlistentry>
<varlistentry>

<term>iso-scan</term><listitem><para>

Looks for ISO file systems, which may be on a CD-ROM or on the 
hard drive.

</para></listitem>
</varlistentry>
<varlistentry>

<term>choose-mirror</term><listitem><para>

Presents a list of Debian archive mirrors. The user may choose
the source of his installation packages.

</para></listitem>
</varlistentry>
<varlistentry>

<term>cdrom-checker</term><listitem><para>

Checks integrity of a CD-ROM. This way the user may assure him/herself
that the installation CD-ROM was not corrupted.

</para></listitem>
</varlistentry>
<varlistentry>

<term>lowmem</term><listitem><para>

Lowmem tries to detect systems with low memory and then does various
tricks to remove unnecessary parts of &d-i; from the memory (at the
cost of some features).

</para></listitem>
</varlistentry>
<varlistentry>

<term>anna</term><listitem><para>

Anna's Not Nearly APT. Installs packages which have been retrieved
from the chosen mirror or CD.

</para></listitem>
</varlistentry>
<varlistentry>

<term>partman</term><listitem><para>

Allows the user to partition disks attached to the system, create file
systems on the selected partitions, and attach them to the
mountpoints. Included are also interesting features like a fully
automatic mode or LVM support. This is the preferred partitioning tool
in Debian.

</para></listitem>
</varlistentry>
<varlistentry>

<term>autopartkit</term><listitem><para>

Automatically partitions an entire disk according to preset 
user preferences.

</para></listitem>
</varlistentry>
<varlistentry>

<term>partitioner</term><listitem><para>

Allows the user to partition disks attached to the system. A 
partitioning program appropriate to your computer's architecture
is chosen.

</para></listitem>
</varlistentry>
<varlistentry>

<term>partconf</term><listitem><para>

Displays a list of partitions, and creates file systems on 
the selected partitions according to user instructions.

</para></listitem>
</varlistentry>
<varlistentry>

<term>lvmcfg</term><listitem><para>

Helps the user with the configuration of the
<firstterm>LVM</firstterm> (Logical Volume Manager).

</para></listitem>
</varlistentry>
<varlistentry>

<term>mdcfg</term><listitem><para>

Allows the user to setup Software <firstterm>RAID</firstterm>
(Redundant Array of Inexpensive Disks). This Software RAID is usually
superior to the cheap IDE (pseudo hardware) RAID controllers found on
newer motherboards.

</para></listitem>
</varlistentry>
<varlistentry>

<term>base-installer</term><listitem><para>

Installs the most basic set of packages which would allow
the computer to operate under Linux when rebooted. 

</para></listitem>
</varlistentry>
<varlistentry>

<term>os-prober</term><listitem><para>

Detects currently installed operating systems on the computer and
passes this information to the bootloader-installer, which may offer
you an ability to add discovered operating systems to the bootloader's
start menu. This way the user could easily choose at the boot time
which operating system to start.

</para></listitem>
</varlistentry>
<varlistentry>

<term>bootloader-installer</term><listitem><para>

Installs a boot loader program on the hard disk, which is necessary
for the computer to start up using Linux without using a floppy or
CD-ROM.  Many boot loaders allow the user to choose an alternate
operating system each time the computer boots.

</para></listitem>
</varlistentry>
<varlistentry>

<term>base-config</term><listitem><para>

Provides dialogs for setting up the base system packages according
to user preferences. This is normally done after rebooting the 
computer; it is the 'first run' of the new Debian system. 

</para></listitem>
</varlistentry>
<varlistentry>

<term>shell</term><listitem><para>

Allows the user to execute a shell from the menu, or in the second
console.

</para></listitem>
</varlistentry>
<varlistentry>

<term>bugreporter</term><listitem><para>

Provides a way for the user to record information on a floppy disk
when trouble is encountered, in order to accurately report installer
software problems to Debian developers later.

</para></listitem>
</varlistentry>

</variablelist>

 </sect1>


<!-- Start of file using-d-i/components.xml -->
<!-- $Id: components.xml 22935 2004-10-09 18:36:20Z fjpop-guest $ -->

 <sect1 id="module-details">
 <title>Using Individual Components</title>
<para>

In this section we will describe each installer component in
detail. The components have been grouped into stages that should
be recognizable for users. They are presented in the order they
appear during the install. Note that not all modules will be used
for every installation; which modules are actually used depends on
the installation method you use and on your hardware.

</para>

  <sect2 id="di-setup">
  <title>Setting up Debian Installer and Hardware Configuration</title>
<para>

Let's assume the Debian Installer has booted and you are facing its
first screen.  At this time, the capabilities of &d-i; are still quite
limited. It doesn't know much about your hardware, preferred language,
or even the task it should perform. Don't worry. Because &d-i; is quite
clever, it can automatically probe your hardware, locate the rest
of its components and upgrade itself to a capable installation system.

However, you still need to help &d-i; with some information it can't
determine automatically (like selecting your preferred language, keyboard
layout or desired network mirror).

</para><para>

You will notice that &d-i; performs <firstterm>hardware detection</firstterm>
several times during this stage. The first time is targeted specifically
at the hardware needed to load installer components (e.g. your CD-ROM or
network card). As not all drivers may be available during this first run,
hardware detection needs to be repeated later in the process.

</para>


<!-- Start of file using-d-i/modules/lowmem.xml -->
<!-- $Id: lowmem.xml 16990 2004-06-19 22:09:49Z fjpop-guest $ -->

  <sect3 id="lowmem">
  <title>Check available memory</title>

<para>

One of the first things &d-i; does, is to check available memory.
If the available memory is limited, this component will make some
changes in the installation process which hopefully will allow
you to install &debian; on your system.

</para><para>

During a low memory install, not all components will be available.
One of the limitations is that you won't be able to choose a
language for the installation.

</para>
   </sect3>
<!--   End of file using-d-i/modules/lowmem.xml -->

<!-- Start of file using-d-i/modules/languagechooser.xml -->
<!-- $Id: languagechooser.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->


   <sect3 id="lang-chooser">
   <title>Language Chooser</title>

<para>

As the first step of the installation, select the language in which
you want the installation process to proceed. The language names
are listed in both English (left side) and in the language itself
(right side); the names on the right side are also shown in the proper
script for the language. The list is sorted on the English names.

</para><para>

The language you choose will be used for the rest of the installation
process, provided a translation of the different dialogs is available.
If no valid translation is available for the selected language, the
installer will default to English. The selected language will also be
used to help select a suitable keyboard layout.

</para>
   </sect3>
<!--   End of file using-d-i/modules/languagechooser.xml -->

<!-- Start of file using-d-i/modules/countrychooser.xml -->
<!-- $Id: countrychooser.xml 23058 2004-10-12 23:51:17Z cjwatson $ -->


   <sect3 id="country-chooser">
   <title>Country Chooser</title>

<para>

If you selected a language in <xref linkend="lang-chooser"/> which has
more than one country associated with it (true for Chinese, English,
French, and many other languages), you can specify the country here.
If you choose <guimenuitem>Other</guimenuitem> at the bottom of the list,
you will be presented with a list of all countries, grouped by continent.

</para><para>

This selection will be used later in the installation process to pick the
default timezone and a Debian mirror appropriate for your geographic
location. If the defaults proposed by the installer are not suitable, you
can make a different choice. The selected country, together with the selected
language, may also affect locale settings for your new Debian system.

</para>
   </sect3>
<!--   End of file using-d-i/modules/countrychooser.xml -->

<!-- Start of file using-d-i/modules/kbd-chooser.xml -->
<!-- $Id: kbd-chooser.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->

   <sect3 id="kbd-chooser">
   <title>Choosing a Keyboard</title>

<para>

Keyboards are often tailored to the characters used in a language.
Select a layout that conforms to the keyboard you are using, or
select something close if the keyboard layout you want
isn't represented. Once the system installation is complete, you'll be
able to select a keyboard layout from a wider range of choices (run
<command>kbdconfig</command> as root after you have completed the
installation).

</para><para>

Move the highlight to the keyboard selection you desire and press
&enterkey;.  Use the arrow keys to move the highlight &mdash; they are
in the same place in all national language keyboard layouts, so they
are independent of the keyboard configuration. An 'extended' keyboard
is one with <keycap>F1</keycap> through <keycap>F10</keycap> keys
along the top row.

</para><para arch="mipsel">

On DECstations there is currently no loadable keymap available,
so you have to skip the keyboard selection and keep the default
kernel keymap (LK201 US). This may change in the future as it
depends on further Linux/MIPS kernel development.

</para><para arch="powerpc">

There are two keyboard layouts for US keyboards; the qwerty/mac-usb-us
(Apple USB) layout will place the Alt function on the
<keycap>Command/Apple</keycap> key (in the keyboard position next to
the <keycap>space</keycap> key similar to <keycap>Alt</keycap> on 
PC keyboards), while the qwerty/us (Standard) layout will place the
Alt function on the <keycap>Option</keycap> key (engraved with 'alt'
on most Mac keyboards). In other respects the two layouts are similar.

</para>
   </sect3>
<!--   End of file using-d-i/modules/kbd-chooser.xml -->

<!-- Start of file using-d-i/modules/s390/netdevice.xml -->
<!-- $Id: netdevice.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/s390/netdevice.xml -->

<!-- Start of file using-d-i/modules/s390/dasd.xml -->
<!-- $Id: dasd.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/s390/dasd.xml -->

<!-- Start of file using-d-i/modules/ddetect.xml -->
<!-- $Id: ddetect.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/ddetect.xml -->

<!-- Start of file using-d-i/modules/cdrom-detect.xml -->
<!-- $Id: cdrom-detect.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/cdrom-detect.xml -->

<!-- Start of file using-d-i/modules/iso-scan.xml -->
<!-- $Id: iso-scan.xml 23058 2004-10-12 23:51:17Z cjwatson $ -->

   <sect3 id="iso-scan">
   <title>Looking for the Debian Installer ISO Image</title>
<para>

When installing via the <emphasis>hd-media</emphasis> method, there
will be a moment where you need to find and mount the Debian Installer
iso image in order to get the rest of the installation files. The
component <command>iso-scan</command> does exactly this.

</para><para>

At first, <command>iso-scan</command> automatically mounts all block
devices (e.g. partitions) which have some known filesystem on them and
sequentially searches for filenames ending with
<filename>.iso</filename> (or <filename>.ISO</filename> for that
matter). Beware that the first attempt scans only files in the root
directory and in the first level of subdirectories (i.e. it finds
<filename>/<replaceable>whatever</replaceable>.iso</filename>,
<filename>/data/<replaceable>whatever</replaceable>.iso</filename>,
but not
<filename>/data/tmp/<replaceable>whatever</replaceable>.iso</filename>).
After an iso image has been found, <command>iso-scan</command> checks
its content to determine if the image is a valid Debian iso image or
not. In the former case we are done, in the latter
<command>iso-scan</command> seeks for another image.

</para><para>

In case the previous attempt to find an installer iso image fails,
<command>iso-scan</command> will ask you whether you would like to
perform a more thorough search. This pass doesn't just look into the
topmost directories, but really traverses whole filesystem.

</para><para>

If <command>iso-scan</command> does not discover your installer iso
image, reboot back to your original operating system and check if the
image is named correctly (ending in <filename>.iso</filename>), if it is
placed on a filesystem recognizable by &d-i;, and if it is not
corrupted (verify the checksum). Experienced Unix users could do this
without rebooting on the second console.

</para>
   </sect3>
<!--   End of file using-d-i/modules/iso-scan.xml -->

<!-- Start of file using-d-i/modules/anna.xml -->
<!-- $Id: anna.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/anna.xml -->

<!-- Start of file using-d-i/modules/netcfg.xml -->
<!-- $Id: netcfg.xml 23058 2004-10-12 23:51:17Z cjwatson $ -->

   <sect3 id="netcfg">
   <title>Configuring Network</title>

<para>

As you enter this step, if the system detects that you have more than
one network device, you'll be asked to choose which device will be
your <emphasis>primary</emphasis> network interface, i.e. the one
which you want to use for installation. The other interfaces won't be
configured at this time. You may configure additional interfaces after
installation is complete; see the <citerefentry>
<refentrytitle>interfaces</refentrytitle> <manvolnum>5</manvolnum>
</citerefentry> man page.

</para><para>

By default, &d-i; tries to configure your computer's network
automatically via DHCP. If the DHCP probe succeeds, you are done. If the
probe fails, it may be caused by many factors ranging from unplugged
network cable, to a misconfigured DHCP setup. Or maybe you don't have
a DHCP server in your local network at all.  For further explanation
check the error messages on the third console.  In any case, you will
be asked if you want to retry, or if you want to perform manual
setup. DHCP servers are sometimes really slow in their responses, so
if you are sure everything is in place, try again.

</para><para>

The manual network setup in turn asks you a number of questions about
your network, notably
<computeroutput>IP address</computeroutput>,
<computeroutput>Netmask</computeroutput>,
<computeroutput>Gateway</computeroutput>,
<computeroutput>Name server addresses</computeroutput>, and a
<computeroutput>Hostname</computeroutput>.
Moreover, if you have a wireless network interface, you will be asked
to provide your <computeroutput>Wireless ESSID</computeroutput> and
a <computeroutput>WEP key</computeroutput>.  Fill in the answers from
<xref linkend="needed-info"/>.

</para><note><para>

Some technical details you might, or might not, find handy: the
program assumes the network IP address is the bitwise-AND of your
system's IP address and your netmask. It will guess the broadcast
address is the bitwise OR of your system's IP address with the bitwise
negation of the netmask. It will also guess your gateway.  If you
can't find any of these answers, use the system's guesses &mdash; you
can change them once the system has been installed, if necessary, by
editing <filename>/etc/network/interfaces</filename>.  Alternatively,
you can install <classname>etherconf</classname>, which will step you
through your network setup.

</para></note>
   </sect3>
<!--   End of file using-d-i/modules/netcfg.xml -->

<!-- Start of file using-d-i/modules/choose-mirror.xml -->
<!-- $Id: choose-mirror.xml 16990 2004-06-19 22:09:49Z fjpop-guest $ -->

<!--
- Component is only selected and executed if the installer needs to load
  installer components or the base system from the network
  (either local or the internet).
- This means you first have to configure a network interface.
- A list of countries is displayed with the default based on the country you
  selected earlier.
- Note that not all mirrors are equal (see http://www.nl.debian.org/mirror/list)
- Selection of a local mirror (at top of the list: manual selection).
- After selecting a country, a list of mirrors in the country will be shown.

- The selected mirror will be tested.
- How to handle problems with mirrors.
-->
<!--   End of file using-d-i/modules/choose-mirror.xml -->

  </sect2>

  <sect2 id="di-partition">
  <title>Partitioning and Mount Point Selection</title>
<para>

At this time, after hardware detection has been executed a final time,
&d-i; should be at its full strength, customized for the user's needs
and ready to do some real work.

As the title of this section indicates, the main task of the next few
components lies in partitioning your disks, creating filesystems,
assigning mountpoints and optionally configuring closely related issues
like LVM or RAID devices.

</para>


<!-- Start of file using-d-i/modules/partman.xml -->
<!-- $Id: partman.xml 24840 2005-01-09 03:34:52Z fjpop-guest $ -->

   <sect3 id="partman">
   <title>Partitioning Your Disks</title>

<para>

Now it is time to partition your disks. If you are uncomfortable with
partitioning, or just want to know more details, see <xref
linkend="partitioning"/>.

</para><para>

First you will be given the opportunity to automatically partition
either an entire drive, or free space on a drive. This is also called
<quote>guided</quote> partitioning. If you do not want to
autopartition, choose <guimenuitem>Manually edit partition
table</guimenuitem> from the menu.

</para><para>

If you choose guided partitioning, you will be able to choose from the
schemes listed in the table below. All schemes have their pros and cons,
some of which are discussed in <xref linkend="partitioning"/>. If you are
unsure, choose the first one. Bear in mind, that guided partitioning
needs certain minimal amount of free space to operate with. If you don't
give it at least about 1GB of space (depends on chosen scheme), guided
partitioning will fail.

</para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
  <entry>Partitioning scheme</entry>
  <entry>Minimum space</entry>
  <entry>Created partitions</entry>
</row>
</thead>

<tbody>
<row>
  <entry>All files in one partition</entry>
  <entry>600MB</entry>
  <entry><filename>/</filename>, swap</entry>
</row><row>
  <entry>Desktop machine</entry>
  <entry>500MB</entry>
  <entry>
    <filename>/</filename>, <filename>/home</filename>, swap
  </entry>
</row><row>
  <entry>Multi-user workstation</entry>
  <entry>1GB</entry>
  <entry>
    <filename>/</filename>, <filename>/home</filename>,
    <filename>/usr</filename>, <filename>/var</filename>,
    <filename>/tmp</filename>, swap
  </entry>
</row>

</tbody></tgroup></informaltable>

<para arch="ia64">

If you chose an automatic partitioning for your IA64 system, there
will be an additional partition, formatted as a FAT16 bootable filesystem,
for the EFI boot loader.
There is also an additional menu item in the formatting menu to manually
set up a partition as an EFI boot partition.

</para><para arch="alpha">

If you chose an automatic partitioning for your Alpha system, an
additional, unformatted partition will be allocated at the beginning of
your disk to reserve this space for the aboot boot loader.

</para><para>

After selecting a scheme, the next screen will show your new partition
table, including information on whether and how partitions will be
formatted and where they will be mounted.

</para><para>

The list of partitions might look like this:

<!-- TODO: show some flags here (lightning, skull, smiley) -->
<informalexample><screen>
  IDE1 master (hda) - 6.4 GB WDC AC36400L
        #1 primary   16.4 MB     ext2       /boot
        #2 primary  551.0 MB     swap       swap
        #3 primary    5.8 GB     ntfs
           pri/log    8.2 MB     FREE SPACE

  IDE1 slave (hdb) - 80.0 GB ST380021A
        #1 primary   15.9 MB     ext3
        #2 primary  996.0 MB     fat16
        #3 primary    3.9 GB     xfs        /home
        #5 logical    6.0 GB     ext3       /
        #6 logical    1.0 GB     ext3       /var
        #7 logical  498.8 GB     ext3
        #8 logical  551.5 GB     swap       swap
        #9 logical   65.8 GB     ext2
</screen></informalexample>

This example shows two IDE harddrives divided into several partitions;
the first disk has some free space. Each partition line consists of the
partition number, its type, size, optional flags, file system, and
mountpoint (if any).

</para><para>

This concludes the guided partitioning. If you are satisfied with the
generated partition table, you can choose <guimenuitem>Finish
partitioning and write changes to disk</guimenuitem> from the menu to
implement the new partition table (as described at the end of this
section). If you are not happy, you can choose to <guimenuitem>Undo
changes to partitions</guimenuitem>, to run guided partitioning again
or modify the proposed changes as described below for manual partitioning.

</para><para>

A similar screen to the one shown just above will be displayed if you
choose manual partitioning except that your existing partition table will
be shown and without the mount points. How to manually setup your partition
table and the usage of partitions by your new Debian system will be covered
in the remainder of this section.

</para><para>

If you select a pristine disk which doesn't have neither partitions
nor free space on it, you will be offered to create a new partition
table (this is needed so you can create new partitions). After this
a new line entitled <quote>FREE SPACE</quote> should appear under the
selected disk.

</para><para>

If you select some free space, you will be offered to create new
partition. You will have to answer a quick series of questions about
its size, type (primary or logical), and location (beginning or end of
the free space). After this, you will be presented with detailed
overview of your new partition. There are options like mountpoint,
mount options, bootable flag, or way of usage. If you don't like the
preselected defaults, feel free to change them to your liking. E.g. by
selecting the option <guimenuitem>Use as:</guimenuitem>, you can
choose different filesystem for this partition including the
possibility to use the partition for swap, software RAID, LVM, or not
use it at all. Other nice feature is the possibility to copy data from
existing partition onto this one.
When you are satisfied with your new partition, select
<guimenuitem>Finished with partition</guimenuitem> and you will be
thrown back to the <command>partman</command>'s main screen.

</para><para>

If you decide you want to change something about your partition,
simply select the partition, which will bring you to the partition
configuration menu. Because this is the same screen like when creating
a new partition, you can change the same set of options. One thing
which might not be very obvious at a first glance is that you can
resize the partition by selecting the item displaying the size of the
partition. Filesystems known to work are at least fat16, fat32, ext2,
ext3 and swap. This menu also allows you to delete a partition.

</para><para>

Be sure to create at least two partitions: one for the
<emphasis>root</emphasis> filesystem (which must be mounted as
<filename>/</filename>) and one for <emphasis>swap</emphasis>. If you
forget to mount the root filesystem, <command>partman</command> won't
let you continue until you correct this issue.

</para><para arch="ia64">

If you forget to select and format an EFI boot partition
<command>partman</command> will detect this and will not let you continue
until you allocate one.

</para><para>

Capabilities of <command>partman</command> can be extended with installer
modules, but are dependent on your system's architecture. So if you can't
see all promised goodies, check if you have loaded all required modules
(e.g. <filename>partman-ext3</filename>, <filename>partman-xfs</filename>,
or <filename>partman-lvm</filename>).

</para><para>

After you are satisfied with partitioning, select <guimenuitem>Finish
partitioning and write changes to disk</guimenuitem> from the partitioning
menu. You will be presented with a summary of changes made to the disks
and asked to confirm that the filesystems should be created as requested.

</para>
   </sect3>
<!--   End of file using-d-i/modules/partman.xml -->

<!-- Start of file using-d-i/modules/autopartkit.xml -->
<!-- $Id: autopartkit.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/autopartkit.xml -->

<!-- Start of file using-d-i/modules/partitioner.xml -->
<!-- $Id: partitioner.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<!--   End of file using-d-i/modules/partitioner.xml -->

<!-- Start of file using-d-i/modules/partconf.xml -->
<!-- $Id: partconf.xml 11648 2004-03-22 00:37:46Z joeyh $ -->
<!--   End of file using-d-i/modules/partconf.xml -->

<!-- Start of file using-d-i/modules/lvmcfg.xml -->
<!-- $Id: lvmcfg.xml 25496 2005-02-07 14:56:06Z fjpop-guest $ -->

   <sect3 id="lvmcfg">
   <title>Configuring Logical Volume Manager (LVM)</title>
<para>

If you are working with computers at the level of system administrator
or <quote>advanced</quote> user, you have surely seen the situation
where some disk partition (usually the most important one) was short on
space, while some other partition was grossly underused and you had to
manage this situation with moving stuff around, symlinking, etc.

</para><para>

To avoid the described situation you can use Logical Volume Manager
(LVM). Simply said, with LVM you can combine your partitions
(<firstterm>physical volumes</firstterm> in LVM lingo) to form
a virtual disc (so called <firstterm>volume group</firstterm>), which
can then be divided into virtual partitions (<firstterm>logical
volumes</firstterm>). The point is that logical volumes (and of course
underlying volume groups) can span across several physical discs.

</para><para>

Now when you realize you need more space for your old 160GB
<filename>/home</filename> partition, you can simply add a new 300GB
disc to the computer, join it with your existing volume group and then
resize the logical volume which holds your <filename>/home</filename>
filesystem and voila &mdash; your users have some room again on their
renewed 460GB partition.  This example is of course a bit
oversimplified. If you haven't read it yet, you should consult the
<ulink url="&url-lvm-howto;">LVM HOWTO</ulink>.

</para><para>

LVM setup in &d-i; is quite simple. At first, you have to mark your
partitions to be used as physical volumes for LVM. (This is done in
<command>partman</command> in the <guimenu>Partition
settings</guimenu> menu where you should select <menuchoice>
<guimenu>Use as:</guimenu> <guimenuitem>physical volume for
LVM</guimenuitem> </menuchoice>.) Then start the
<command>lvmcfg</command> module (either directly from
<command>partman</command> or from the &d-i;'s main menu) and combine
physical volumes to volume group(s) under the <guimenuitem>Modify
volume groups (VG)</guimenuitem> menu. After that, you should create
logical volumes on the top of volume groups from the menu
<guimenuitem>Modify logical volumes (LV)</guimenuitem>.

<note arch="powerpc"><para> 

There is no widely accepted standard to identify partitions containing
LVM data on Apple Power Macintosh hardware. On this particular
hardware, the above procedure for creating physical volumes and volume
groups will not work. There is a good workaround for this limitation,
provided you are familiar with the underlying LVM tools.

</para><para>
 
To install using logical volumes on Power Macintosh hardware you
should create all the disk partitions for your logical volumes as
usual. In the <guimenu>Partition settings</guimenu> menu you should
choose <menuchoice><guimenu>Use as:</guimenu> <guimenuitem>Do Not
Use</guimenuitem></menuchoice> for these partitions (you will not be
offered the option to use the partition as a physical volume). When
you are done with creating all your partitions, you should start the
logical volume manager as usual. However, since no physical volumes
have been created you must now access the command shell available on
the second virtual terminal (see <xref linkend="shell"/>) and create
them manually.

</para><para>

Use the <command>pvcreate</command> command at the shell command prompt
to create a physical volume on each of your chosen partitions. Then use
the <command>vgcreate</command> command to create each volume group
you want. You can safely ignore any errors about incorrect metadata
area header checksums and fsync failures while doing this. When you
have finished creating all your volume groups, you should go back to
the first virtual terminal and skip directly to the
<command>lvmcfg</command> menu items for logical volume
management. You will see your volume groups and you can create the
logical volumes you need as usual.

</para></note>

</para><para>

After returning from <command>lvmcfg</command> back to
<command>partman</command>, you will see any created logical volumes
in the same way as ordinary partitions (and you should treat them like
that).

</para>
   </sect3>
<!--   End of file using-d-i/modules/lvmcfg.xml -->

<!-- Start of file using-d-i/modules/mdcfg.xml -->
<!-- $Id: mdcfg.xml 24840 2005-01-09 03:34:52Z fjpop-guest $ -->

   <sect3 id="mdcfg">
   <title>Configuring Multidisk Device (Software RAID)</title>
<para>

If you have more than one harddrive<footnote><para>

To be honest, you can construct MD device even from partitions
residing on single physical drive, but that won't bring you anything
useful.

</para></footnote> in your computer, you can use
<command>mdcfg</command> to setup your drives for increased
performance and/or better reliability of your data. The result is
called <firstterm>Multidisk Device</firstterm> (or after its most
famous variant <firstterm>software RAID</firstterm>).

</para><para>

MD is basically a bunch of partitions located on different disks and
combined together to form a <emphasis>logical</emphasis> device. This
device can then be used like an ordinary partition (i.e. in
<command>partman</command> you can format it, assign a mountpoint,
etc.).

</para><para>

The benefit you gain depends on a type of a MD device you are
creating. Currently supported are:

<variablelist>
<varlistentry>

<term>RAID0</term><listitem><para>

Is mainly aimed at performance.  RAID0 splits all incoming data into
<firstterm>stripes</firstterm> and distributes them equally over each
disk in the array. This can increase the speed of read/write
operations, but when one of the disks fails, you will loose
<emphasis>everything</emphasis> (part of the information is still on
the healthy disk(s), the other part <emphasis>was</emphasis> on the
failed disk).

</para><para>

The typical use for RAID0 is a partition for video editing.

</para></listitem>
</varlistentry>
<varlistentry>

<term>RAID1</term><listitem><para>

Is suitable for setups where reliability is the first concern.  It
consists of several (usually two) equally sized partitions where every
partition contains exactly the same data. This essentially means three
things.  First, if one of your disks fails, you still have the data
mirrored on the remaining disks. Second, you can use only a fraction
of the available capacity (more precisely, it is the size of the
smallest partition in the RAID). Third, file reads are load balanced among
the disks, which can improve performance on a server, such as a file
server, that tends to be loaded with more disk reads than writes.

</para><para>

Optionally you can have a spare disk in the array which will take the
place of the failed disk in the case of failure.

</para></listitem>
</varlistentry>
<varlistentry>

<term>RAID5</term><listitem><para>

Is a good compromise between speed, reliability and data redundancy.
RAID5 splits all incomming data into stripes and distributes them
equally on all but one disks (similar to RAID0). Unlike RAID0, RAID5
also computes <firstterm>parity</firstterm> information, which gets
written on the remaining disk. The parity disk is not static (that
would be called RAID4), but is changing periodically, so the parity
information is distributed equally on all disks.  When one of the
disks fails, the missing part of information can be computed from
remaining data and its parity. RAID5 must consist of at least three
active partitions. Optionally you can have a spare disk in the array
which will take the place of the failed disk in the case of failure.

</para><para>

As you can see, RAID5 has similar degree of reliability like RAID1
while achieving less redundancy. On the other hand it might be a bit
slower on write operation than RAID0 due to computation of parity
information.

</para></listitem>
</varlistentry>
</variablelist>

To sum it up:

<informaltable>
<tgroup cols="5">
<thead>
<row>
  <entry>Type</entry>
  <entry>Minimum Devices</entry>
  <entry>Spare Device</entry>
  <entry>Survives disk failure?</entry>
  <entry>Available Space</entry>
</row>
</thead>

<tbody>
<row>
  <entry>RAID0</entry>
  <entry>2</entry>
  <entry>no</entry>
  <entry>no</entry>
  <entry>Size of the smallest partition multiplied by number of devices in RAID</entry>
</row>

<row>
  <entry>RAID1</entry>
  <entry>2</entry>
  <entry>optional</entry>
  <entry>yes</entry>
  <entry>Size of the smallest partition in RAID</entry>
</row>

<row>
  <entry>RAID5</entry>
  <entry>3</entry>
  <entry>optional</entry>
  <entry>yes</entry>
  <entry>
    Size of the smallest partition multiplied by (number of devices in
    RAID minus one)
  </entry>
</row>

</tbody></tgroup></informaltable>

</para><para>

If you want to know the whole truth about Software RAID, have a look
at <ulink url="&url-software-raid-howto;">Software RAID HOWTO</ulink>.

</para><para>

To create a MD device, you need to have the desired partitions it
should consist of marked for use in a RAID.  (This is done in
<command>partman</command> in the <guimenu>Partition
settings</guimenu> menu where you should select <menuchoice>
<guimenu>Use as:</guimenu> <guimenuitem>Use the partition as a RAID
device</guimenuitem> </menuchoice>.)

</para><warning><para>

Support for MD is a relatively new addition to the installer.
You may experience problems for some RAID levels and in combination
with some bootloaders if you try to use MD for the root
(<filename>/</filename>) filesystem. For experienced users, it may be
possible to work around some of these problems by executing some
configuration or installation steps manually from a shell.

</para></warning><para>

Next, you should choose <guimenuitem>Configure software
RAID</guimenuitem> from the main <command>partman</command> menu.
On the first screen of <command>mdcfg</command> simply select
<guimenuitem>Create MD device</guimenuitem>. You will be presented with
a list of supported types of MD devices, from which you should choose
one (e.g. RAID1). What follows depends on the type of MD you selected.
</para>

<itemizedlist>
<listitem><para>

RAID0 is simple &mdash; you will be issued with the list of available
RAID partitions and your only task is to select the partitions which
will form the MD.

</para></listitem>
<listitem><para>

RAID1 is a bit more tricky. First, you will be asked to enter the
number of active devices and the number of spare devices which will
form the MD. Next, you need to select from the list of available RAID
partitions those that will be active and then those that will be
spare. The count of selected partitions must be equal to the number
provided few seconds ago. Don't worry. If you make a mistake and
select different number of partitions, the &d-i; won't let you
continue until you correct the issue.

</para></listitem>
<listitem><para>

RAID5 has similar setup procedure as RAID1 with the exception that you
need to use at least <emphasis>three</emphasis> active partitions.

</para></listitem>
</itemizedlist>

<para>

It is perfectly possible to have several types of MD at once. For
example if you have three 200 GB hard drives dedicated to MD, each
containing two 100 GB partitions, you can combine first partitions on
all three disk into the RAID0 (fast 300 GB video editing partition)
and use the other three partitions (2 active and 1 spare) for RAID1
(quite reliable 100 GB partition for <filename>/home</filename>).

</para><para>

After you setup MD devices to your liking, you can
<guimenuitem>Finish</guimenuitem> <command>mdcfg</command> to return
back to the <command>partman</command> to create filesystems on your
new MD devices and assign them the usual attributes like mountpoints.

</para>
   </sect3>
<!--   End of file using-d-i/modules/mdcfg.xml -->
  </sect2>

  <sect2 id="di-install-base">
  <title>Installing the Base System</title>
<para>

Although this stage is the least problematic, it consumes most time of
the install because it downloads, verifies and unpacks the whole base
system. If you have a slow computer or network connection, this could
take some time.

</para>


<!-- Start of file using-d-i/modules/base-installer.xml -->
<!-- $Id: base-installer.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->

   <sect3 id="base-installer">
   <title>Base System Installation</title>

<para>

During the Base installation, package unpacking and setup messages are
redirected to <userinput>tty3</userinput>.  You can access this
terminal by pressing 
<keycombo><keycap>Left Alt</keycap><keycap>F3</keycap></keycombo>; 
get back to the main installer process with 
<keycombo><keycap>Left Alt</keycap><keycap>F1</keycap></keycombo>.


</para><para>

The unpack/setup messages generated by the base installation are saved in
<filename>/var/log/messages</filename> when the installation is
performed over a serial console.

</para><para>

As part of the installation, a Linux kernel will be installed. At the default
priority, the installer will choose one for you that best matches your
hardware. In lower priority modes, you will be able to choose from a list
of available kernels.

</para>
   </sect3>
<!--   End of file using-d-i/modules/base-installer.xml -->
  </sect2>

  <sect2 id="di-make-bootable">
  <title>Making Your System Bootable</title>

<para condition="supports-nfsroot">

If you are installing a diskless workstation, obviously, booting off
the local disk isn't a meaningful option, and this step will be
skipped. <phrase arch="sparc">You may wish to set the OpenBoot to boot
from the network by default; see <xref
linkend="boot-dev-select-sun"/>.</phrase>

</para><para>

Note that multiple operating systems booting on a single machine is
still something of a black art.  This document does not even attempt
to document the various boot managers, which vary by architecture and
even by subarchitecture.  You should see your boot manager's
documentation for more information.

</para>


<!-- Start of file using-d-i/modules/os-prober.xml -->
<!-- $Id: os-prober.xml 22664 2004-10-06 15:49:49Z fjpop-guest $ -->

   <sect3 id="os-prober">
   <title>Detecting other operating systems</title>

<para>

Before a boot loader is installed, the installer will attempt to probe for
other operating systems which are installed on the machine. If it finds a
supported operating system, you will be informed of this during the boot
loader installation step, and the computer will be configured to boot this
other operating system in addition to Debian.

</para><para>

Note that multiple operating systems booting on a single machine is still
something of a black art. The automatic support for detecting and setting
up boot loaders to boot other operating systems varies by architecture and
even by subarchitecture. If it does not work you should consult your
boot manager's documentation for more information.

<!-- TODO: Maybe include some arch-dependent tables with supported OS'es here -->

</para>

<note><para>

The installer may fail to detect other operating systems if the partitions on
which they reside are mounted when the detection takes place. This may occur if
you select a mountpoint (e.g. /win) for a partition containing another operating
system in <command>partman</command>, or if you have mounted partitions manually
from a console.

</para></note>

   </sect3>
<!--   End of file using-d-i/modules/os-prober.xml -->

<!-- Start of file using-d-i/modules/alpha/aboot-installer.xml -->
<!-- $Id: aboot-installer.xml 25496 2005-02-07 14:56:06Z fjpop-guest $ -->

  <sect3 arch="alpha">
  <title>Install <command>aboot</command> on a Hard Disk</title>
<para>

If you have booted from SRM, if you select this option, the installer
will write <command>aboot</command> to the first sector of the disk on
which you installed Debian.  Be <emphasis>very</emphasis> careful &mdash; it
is <emphasis>not</emphasis> possible to boot multiple operating
systems (e.g. GNU/Linux, Free/Open/NetBSD, OSF/1 a.k.a. Digital Unix
a.k.a. Tru64 Unix, or OpenVMS) from the same disk.  If you also have a
different operating system installed on the disk where you have
installed Debian, you will have to boot GNU/Linux from a floppy
instead.

</para>
  </sect3>
<!--   End of file using-d-i/modules/alpha/aboot-installer.xml -->

<!-- Start of file using-d-i/modules/hppa/palo-installer.xml -->
<!-- $Id: palo-installer.xml 14602 2004-05-02 16:31:59Z mck-guest $ -->

  <sect3 arch="hppa">
  <title><command>palo</command>-installer</title>
<para>

The bootloader on PA-RISC is <quote>palo</quote>.
<command>PALO</command> is similar in configuration and usage to
<command>LILO</command>, with a few exceptions.  First of all,
<command>PALO</command> allows you to boot any kernel image on your
boot partition.  This is because <command>PALO</command> can actually
read Linux partitions.

</para><para condition="FIXME">

hppa FIXME ( need more info )

</para>
  </sect3>
<!--   End of file using-d-i/modules/hppa/palo-installer.xml -->

<!-- Start of file using-d-i/modules/i386/grub-installer.xml -->
<!-- $Id: grub-installer.xml 18640 2004-07-27 21:53:59Z joeyh $ -->

  <sect3 arch="i386">
  <title>Install the <command>Grub</command> Boot Loader
         on a Hard Disk</title>
<para>

The main &architecture; boot loader is called <quote>grub</quote>.
Grub is a flexible and robust boot loader and a good default choice for
newbies and old hands alike.

</para><para>

By default, grub will be installed into the Master Boot Record (MBR), where
it will take over complete control of the boot process. If you prefer, you
can install it elsewhere. See the grub manual for complete information.

</para><para>

If you do not want to install grub at all, use the Back button to get to
the main menu, and from there select whatever bootloader you would like to
use.

</para>
  </sect3>
<!--   End of file using-d-i/modules/i386/grub-installer.xml -->

<!-- Start of file using-d-i/modules/i386/lilo-installer.xml -->
<!-- $Id: lilo-installer.xml 22935 2004-10-09 18:36:20Z fjpop-guest $ -->

  <sect3 arch="i386">
  <title>Install the <command>LILO</command> Boot Loader
         on a Hard Disk</title>
<para>

The second &architecture; boot loader is called <quote>LILO</quote>.
It is an old complex program which offers lots of functionality,
including DOS, Windows, and OS/2 boot management.  Please carefully
read the instructions in the directory
<filename>/usr/share/doc/lilo/</filename> if you have special needs;
also see the <ulink url="&url-lilo-howto;">LILO mini-HOWTO</ulink>.

</para>
<note><para>

Currently the LILO installation will only create menu entries for other
operating systems if these can be <firstterm>chainloaded</firstterm>.
This means you may have to manually add a menu entry for operating
systems like GNU/Linux and GNU/Hurd after the installation.

</para></note>
<para>

&d-i; presents you three choices where to install the
<command>LILO</command> boot loader:

<variablelist>
<varlistentry>
<term>Master Boot Record (MBR)</term><listitem><para>

This way the <command>LILO</command> will take complete control of the
boot process.

</para></listitem></varlistentry>
<varlistentry>
<term>new Debian partition</term><listitem><para>

Choose this if you want to use another boot
manager. <command>LILO</command> will install itself at the beginning
of the new Debian partition and it will serve as a secondary boot
loader.

</para></listitem></varlistentry>
<varlistentry>
<term>Other choice</term><listitem><para>

Useful for advanced users who want to install <command>LILO</command>
somewhere else. In this case you will be asked for desired
location. You can use devfs style names, such as those that start with
<filename>/dev/ide</filename>, <filename>/dev/scsi</filename>, and
<filename>/dev/discs</filename>, as well as traditional names, such as
<filename>/dev/hda</filename> or <filename>/dev/sda</filename>.

</para></listitem></varlistentry>
</variablelist>

</para><para>

If you can no longer boot into Windows 9x (or DOS) after this step,
you'll need to use a Windows 9x (MS-DOS) boot disk and use the
<userinput>fdisk /mbr</userinput> command to reinstall the MS-DOS
master boot record &mdash; however, this means that you'll need to use
some other way to get back into Debian! For more information on this
please read <xref linkend="reactivating-win"/>.

</para>
  </sect3>
<!--   End of file using-d-i/modules/i386/lilo-installer.xml -->

<!-- Start of file using-d-i/modules/ia64/elilo-installer.xml -->
<!-- $Id: elilo-installer.xml 24321 2004-12-08 17:05:45Z fjpop-guest $ -->

  <sect3 arch="ia64">
  <title>Install the <command>ELILO</command> Boot Loader
         on a Hard Disk</title>
<para>

The &architecture; boot loader is called <quote>elilo</quote>.
It is modeled on the <quote>lilo</quote> boot loader for the
x86 architecture and uses a similar configuration file.
However, instead of writing an MBR or partition boot record to
the disk, it copies the necessary files to a separate FAT formatted
disk partition and modifies the <guimenuitem>EFI Boot Manager</guimenuitem>
menu in the firmware to point to the files in the EFI partition.
The <command>elilo</command> boot loader is really in two parts.
The <filename>/usr/sbin/elilo</filename> command manages the partition and
copies file into it.
The <filename>elilo.efi</filename> program is copied into the EFI
partition and then run by the <quote>EFI Boot Manager</quote> to actually
do the work of loading and starting the Linux kernel.

</para><para>

The <quote>elilo</quote> configuration and installation is done as the
last step of installing the packages of the base installation.
&d-i; will present you with a list of potential disk partitions that it
has found suitable for an EFI partition.
Select the partition you set up earlier in the installation, typically
a partition on the same disk that contains your
<emphasis>root</emphasis> filesystem.

</para>

  <warning><title>Choose the correct partition!</title>

<para>

The criteria for selecting a partition is that it is FAT format
filesystem with its <emphasis>boot</emphasis> flag set.
&d-i; may show multiple choices depending on what it finds from scanning
all of the disks of the system including EFI partitions of other system
disks and EFI diagnostic partitions.
Remember, the <command>elilo</command> may format the partition during
the installation, erasing any previous contents!

</para></warning>

  </sect3>

  <sect3 arch="ia64">
  <title>EFI Partition Contents</title>

<para>

The EFI partition is a FAT filesystem format partition on one of the
hard disks of the system, usually the same disk that contains the
<emphasis>root</emphasis> filesystem.
It is normally not mounted on a running system as it is only needed
by the <quote>EFI Boot Manager</quote> to load the system and the
installer part of the <command>elilo</command> writes to the filesystem
directly.
The <command>/usr/sbin/elilo</command> utility writes the following files
into the <filename>efi/debian</filename> directory of the EFI
partition during the installation.
Note that the <quote>EFI Boot Manager</quote> would find these files
using the path <filename>fs<replaceable>n</replaceable>:\efi\debian</filename>.
There may be other files in this filesystem as well over time as
the system is updated or re-configured.

</para>

<variablelist>

<varlistentry>
<term><filename>elilo.conf</filename></term>
<listitem><para>

This is the configuration file read by the boot loader when it starts.
It is a copy of the <filename>/etc/elilo.conf</filename> with
the filenames re-written to refer to files in the EFI partition.

</para></listitem></varlistentry>

<varlistentry>
<term><filename>elilo.efi</filename></term>
<listitem><para>

This is the boot loader program that the <quote>EFI Boot Manager</quote>
runs to boot the system.
It is the program behind the <guimenuitem>Debian GNU/Linux</guimenuitem>
menu item of the <quote>EFI Boot Manager</quote> command menu.

</para></listitem></varlistentry>

<varlistentry>
<term><filename>initrd.img</filename></term>
<listitem><para>

This is the initial root filesystem used to boot the kernel.
It is a copy of the file referenced in the
<filename>/etc/elilo.conf</filename>.
In a standard Debian installation it would be the file in
<filename>/boot</filename> pointed to by the symbolic link
<filename>/initrd.img</filename>.

</para></listitem></varlistentry>

<varlistentry>
<term><filename>readme.txt</filename></term>
<listitem><para>

This is a small text file warning you that the contents of the
directory are managed by the <command>elilo</command> and that
any local changes would be lost at the next time
<filename>/usr/sbin/elilo</filename> is run.

</para></listitem></varlistentry>

<varlistentry>
<term><filename>vmlinuz</filename></term>
<listitem><para>

This is the compressed kernel itself.
It is a copy of the file referenced in the
<filename>/etc/elilo.conf</filename>.
In a standard Debian installation it would be the file in
<filename>/boot</filename> pointed to by the symbolic link
<filename>/vmlinuz</filename>.

</para></listitem></varlistentry>

</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/ia64/elilo-installer.xml -->

<!-- Start of file using-d-i/modules/mips/arcboot-installer.xml -->
<!-- $Id: arcboot-installer.xml 24663 2004-12-31 18:38:22Z fjpop-guest $ -->

  <sect3 arch="mips">
  <title><command>arcboot</command>-installer</title>
<para>

The boot loader on SGI Indys is <command>arcboot</command>.
It has to be installed on the same hard disk as the kernel (this is done
automatically by the installer). Arcboot supports different configurations
which are set up in <filename>/etc/arcboot.conf</filename>. Each
configuration has a unique name,
the default setup as created by the installer is <quote>linux</quote>.
After arcboot has been installed, the system can be booted from hard disk
by setting some firmware environment variables entering

<informalexample><screen>
<userinput> setenv SystemPartition scsi(<replaceable>scsi</replaceable>)disk(<replaceable>disk</replaceable>)rdisk(0)partition(0)</userinput>
<userinput> setenv OSLoadPartition scsi(<replaceable>scsi</replaceable>)disk(<replaceable>disk</replaceable>)rdisk(0)partition(<replaceable>partnr</replaceable>)</userinput>
<userinput> setenv OSLoader arcboot</userinput>
<userinput> setenv OSLoadFilename <replaceable>config</replaceable></userinput>
<userinput> setenv AutoLoad yes</userinput>
</screen></informalexample>

on the firmware prompt, and then typing <command>boot</command>.

</para>

<variablelist>
<varlistentry>
<term> <replaceable>scsi</replaceable> </term>
<listitem><para>

is the SCSI bus to be booted from, this is <userinput>0</userinput>
for the onboard controllers

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>disk</replaceable> </term>
<listitem><para>

is the SCSI ID of the hard disk on which <command>arcboot</command> is
installed

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>partnr</replaceable> </term>
<listitem><para>

is the number of the partition on which
<filename>/etc/arcboot.conf</filename> resides

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>config</replaceable> </term>
<listitem><para>

is the name of the configuration entry in
<filename>/etc/arcboot.conf</filename>, which is <quote>linux</quote> by
default.

</para></listitem>
</varlistentry>
</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/mips/arcboot-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/colo-installer.xml -->
<!-- $Id: colo-installer.xml 14337 2004-04-24 15:05:40Z mck-guest $ -->
<!--   End of file using-d-i/modules/mipsel/colo-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/delo-installer.xml -->
<!-- $Id: delo-installer.xml 24663 2004-12-31 18:38:22Z fjpop-guest $ -->

  <sect3 arch="mipsel">
  <title><command>delo</command>-installer</title>
<para>

The boot loader on DECstations is <command>DELO</command>.
It has to be installed on the same hard disk as the kernel (this is done
automatically by the installer). DELO supports different configurations
which are set up in <filename>/etc/delo.conf</filename>. Each
configuration has a unique name,
the default setup as created by the installer is <quote>linux</quote>.
After DELO has been installed, the system can be booted from hard disk
by entering

<informalexample><screen>
<userinput>boot <replaceable>#</replaceable>/rz<replaceable>id</replaceable> <replaceable>partnr</replaceable>/<replaceable>name</replaceable></userinput>
</screen></informalexample>

on the firmware prompt.

</para>

<variablelist>
<varlistentry>
<term> <replaceable>#</replaceable> </term>
<listitem><para>

is the TurboChannel device to be booted from, on most DECstations this
is <userinput>3</userinput> for the onboard controllers

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>id</replaceable> </term>
<listitem><para>

is the SCSI ID of the hard disk on which <command>DELO</command> is
installed

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>partnr</replaceable> </term>
<listitem><para>

is the number of the partition on which
<filename>/etc/delo.conf</filename> resides

</para></listitem>
</varlistentry>
<varlistentry>
<term> <replaceable>name</replaceable> </term>
<listitem><para>

is the name of the configuration entry in
<filename>/etc/delo.conf</filename>, which is <quote>linux</quote> by
default.

</para></listitem>
</varlistentry>
</variablelist>

<para>

In case <filename>/etc/delo.conf</filename> is on the first partition
on the disk and the default configuration shall be booted, it is
sufficient to use

<informalexample><screen>
<userinput>boot #/rz<replaceable>id</replaceable></userinput>
</screen></informalexample>

</para>
  </sect3>
<!--   End of file using-d-i/modules/mipsel/delo-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/yaboot-installer.xml -->
<!-- $Id: yaboot-installer.xml 14975 2004-05-08 13:28:15Z mck-guest $ -->

  <sect3 arch="powerpc">
  <title>Install <command>Yaboot</command> on a Hard Disk</title>
<para>

Newer (mid 1998 and on) PowerMacs use <command>yaboot</command> as
their boot loader. The installer will set up <command>yaboot</command>
automatically, so all you need is a small 820k partition named
<quote>bootstrap</quote> with type
<emphasis>Apple_Bootstrap</emphasis> created back in the partitioning
component.  If this step completes successfully then your disk should
now be bootable and OpenFirmware will be set to boot &debian;.

</para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/yaboot-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/quik-installer.xml -->
<!-- $Id: quik-installer.xml 14975 2004-05-08 13:28:15Z mck-guest $ -->

  <sect3 arch="powerpc">
  <title>Install <command>Quik</command> on a Hard Disk</title>
<para>

The boot loader for OldWorld Power Macintosh machines is
<command>quik</command>.  You can also use it on CHRP. The installer
will attempt to set up <command>quik</command> automatically. The
setup has been known to work on 7200, 7300, and 7600 Powermacs, and on
some Power Computing clones.

</para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/quik-installer.xml -->

<!-- Start of file using-d-i/modules/s390/zipl-installer.xml -->
<!-- $Id: zipl-installer.xml 14602 2004-05-02 16:31:59Z mck-guest $ -->

  <sect3 arch="s390">
  <title><command>zipl</command>-installer</title>
<para>

The boot loader on &arch-title; is <quote>zipl</quote>.
<command>ZIPL</command> is similar in configuration and usage to
<command>LILO</command>, with a few exceptions.  Please take a look at
<quote>LINUX for &arch-title; Device Drivers and Installation
Commands</quote> from IBM's developerWorks web site if you want to
know more about <command>ZIPL</command>.

</para>
  </sect3>
<!--   End of file using-d-i/modules/s390/zipl-installer.xml -->

<!-- Start of file using-d-i/modules/sparc/silo-installer.xml -->
<!-- $Id: silo-installer.xml 24582 2004-12-27 02:16:29Z cjwatson $ -->

  <sect3 arch="sparc">
  <title>Install the <command>SILO</command> Boot Loader
         on a Hard Disk</title>
<para>

The standard &architecture; boot loader is called <quote>silo</quote>.
It is documented in
<filename>/usr/share/doc/silo/</filename>. <command>SILO</command> is
similar in configuration and usage to <command>LILO</command>, with
a few exceptions. First of all, <command>SILO</command> allows you to
boot any kernel image on your drive, even if it is not listed in
<filename>/etc/silo.conf</filename>.  This is because
<command>SILO</command> can actually read Linux partitions.  Also,
<filename>/etc/silo.conf</filename> is read at boot time, so there is
no need to rerun <command>silo</command> after installing a new kernel
like you would with <command>LILO</command>. <command>SILO</command>
can also read UFS partitions, which means it can boot SunOS/Solaris
partitions as well. This is useful if you want to install GNU/Linux
alongside an existing SunOS/Solaris install.

</para>
  </sect3>
<!--   End of file using-d-i/modules/sparc/silo-installer.xml -->

<!-- Start of file using-d-i/modules/nobootloader.xml -->
<!-- $Id: nobootloader.xml 23662 2004-11-07 21:29:33Z fjpop-guest $ -->

   <sect3 id="nobootloader">
   <title>Continue Without Boot Loader</title>

<para>

This option can be used to complete the installation even when no boot
loader is to be installed, either because the arch/subarch doesn't
provide one, or because none is desired (e.g. you will use existing
boot loader). <phrase arch="m68k">This option is especially useful for
Macintosh, Atari, and Amiga systems, where the original operating system
must be maintained on the box and used to boot GNU/Linux.</phrase>

</para><para>

If you plan to manually configure your bootloader, you should check the
name of the installed kernel in <filename>/target/boot</filename>.
You should also check that directory for the presence of an
<firstterm>initrd</firstterm>; if one is present, you will probably have
to instruct your bootloader to use it. Other information you will need
are the disk and partition you selected for your <filename>/</filename>
filesystem and, if you chose to install <filename>/boot</filename> on a
separate partition, also your <filename>/boot</filename> filesystem.

</para>
   </sect3>
<!--   End of file using-d-i/modules/nobootloader.xml -->
  </sect2>

  <sect2 id="di-finish">
  <title>Finishing the First Stage</title>
<para>

These are the last bits to do before rebooting to your new Debian. It
mostly consists of tidying up after the &d-i;.

</para>


<!-- Start of file using-d-i/modules/prebaseconfig.xml -->
<!-- $Id: prebaseconfig.xml 21672 2004-09-15 10:55:50Z fjpop-guest $ -->

   <sect3 id="prebaseconfig">
   <title>Finish the Installation and Reboot</title>

<para>

This is the last step in the initial Debian installation process. You will
be prompted to remove the boot media (CD, floppy, etc) that you used to
boot the installer. The installer will do any last minute tasks, and then
reboot into your new Debian system.

</para><para arch="s390">

Select the <guimenuitem>Finish the installation</guimenuitem>
menu item which will halt the system
because rebooting is not supported on &arch-title; in this case. You
then need to IPL GNU/Linux from the DASD which you selected for the
root filesystem during the first steps of the installation.

</para>
   </sect3>
<!--   End of file using-d-i/modules/prebaseconfig.xml -->
  </sect2>

  <sect2 id="di-miscellaneous">
  <title>Miscellaneous</title>
<para>

The components listed in this section are usually not involved in the
installation process, but are waiting in the background to help the
user in case something goes wrong.

</para>


<!-- Start of file using-d-i/modules/bugreporter.xml -->
<!-- $Id: bugreporter.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->

   <sect3 id="bugreporter">
   <title>Saving the installation logs</title>

<para>

If the installation is successful, the logfiles created during
the installation process will be automatically saved to
<filename>/var/log/debian-installer/</filename> on your new
Debian system.

</para><para>

Choosing <guimenuitem>Save debug logs</guimenuitem> from the main
menu allows you to save the log files to a floppy disk. This can
be useful if you encounter fatal problems during the installation
and wish to study the logs on another system or attach them to an
installation report.

</para>
   </sect3>
<!--   End of file using-d-i/modules/bugreporter.xml -->

<!-- Start of file using-d-i/modules/cdrom-checker.xml -->
<!-- $Id: cdrom-checker.xml 14337 2004-04-24 15:05:40Z mck-guest $ -->
<!--   End of file using-d-i/modules/cdrom-checker.xml -->

<!-- Start of file using-d-i/modules/shell.xml -->
<!-- $Id: shell.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->

   <sect3 id="shell">
   <title>Using the Shell and Viewing the Logs</title>
   <!-- TODO: There is nothing about logs in this section! -->

<para>

There is an <guimenuitem>Execute a Shell</guimenuitem> item on the
menu. If the menu is not available when you need to use the shell,
press <keycombo><keycap>Left Alt</keycap> <keycap>F2</keycap></keycombo>
(on a Mac keyboard, <keycombo><keycap>Option</keycap> <keycap>F2</keycap>
</keycombo>) to switch to the second <emphasis>virtual
console</emphasis>. That's the <keycap>Alt</keycap> key on the
left-hand side of the <keycap>space bar</keycap>, and the
<keycap>F2</keycap> function key, at the same time. This is a separate
window running a Bourne shell clone called <command>ash</command>.

</para><para>

At this point you are booted from the RAM disk, and there is a limited
set of Unix utilities available for your use. You can see what
programs are available with the command <command>ls /bin /sbin /usr/bin
/usr/sbin</command> and by typing <command>help</command>. The
text editor is <command>nano</command>. The shell has some nice features
like autocompletion and history.

</para><para>

Use the menus to perform any task that they are able to do &mdash; the
shell and commands are only there in case something goes wrong.  In
particular, you should always use the menus, not the shell, to
activate your swap partition, because the menu software can't detect
that you've done this from the shell. Press <keycombo><keycap>Left
Alt</keycap> <keycap>F1</keycap></keycombo> to get back to menus, or
type <command>exit</command> if you used a menu item to open the
shell.

</para>
   </sect3>
<!--   End of file using-d-i/modules/shell.xml -->

<!-- Start of file using-d-i/modules/baseconfig.xml -->
<!-- $Id: baseconfig.xml 21579 2004-09-13 22:57:14Z fjpop-guest $ -->

   <sect3 id="baseconfig">
   <title>Running <command>base-config</command> From Within &d-i;</title>

<para>

It is possible to configure the base system within the first stage
installer (before rebooting from the hard drive), by running
<command>base-config</command> in a <firstterm>chroot</firstterm>
environment. This is mainly useful for testing the installer and a
vast majority of people should avoid it.
<!-- Feel free to prove me I'm wrong -->

</para>
   </sect3>
<!--   End of file using-d-i/modules/baseconfig.xml -->
  </sect2>
 </sect1>
<!--   End of file using-d-i/components.xml -->

</chapter>

<!--   End of file using-d-i/using-d-i.xml -->
