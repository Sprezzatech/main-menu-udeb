<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Debian Installer internals</title>
<link rel="stylesheet" href="talk.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<meta name="description" content="
The Debian Installer is sometimes described as a mini Linux distribution which gives an indication of its complexity. This paper gives an introduction to the inner workings of the installer when it is running, its components (udebs) and its build system.
">
<link rel="start" href="index.html" title="Debian Installer internals">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Debian Installer internals</th></tr></table>
<hr>
</div>
<div class="article" lang="en">
<div class="titlepage">
<div>
<div><h1 class="title">
<a name="id2408867"></a>Debian Installer internals</h1></div>
<div><div class="authorgroup"><div class="author"><h3 class="author">
<span class="firstname">Frans</span> <span class="surname">Pop</span>
</h3></div></div></div>
<div><p class="copyright">Copyright © 2006 <span class="trademark"></span>© Frans Pop <code class="email">&lt;<a href="mailto:fjp@debian.org">fjp@debian.org</a>&gt;</code></p></div>
<div><div class="legalnotice">
<a name="id2534384"></a><p>
This article is free; you may redistribute it and/or modify it
under the terms of version 2 of the GNU General Public License. 
</p>
</div></div>
<div><div class="abstract">
<p class="title"><b>Abstract</b></p>
<p>
The Debian Installer is sometimes described as a mini Linux distribution which gives an indication of its complexity. This paper gives an introduction to the inner workings of the installer when it is running, its components (udebs) and its build system.
</p>
</div></div>
</div>
<hr>
</div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="index.html#id2534366">1. Running Debian Installer</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="index.html#id2476306">1.1. Installation methods</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2468398">1.2. The boot process</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2468709">1.3. The Debian Installer Menu</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2534702">1.4. Hooks provide additional flexibility</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2534804">1.5. Some special tools</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2534942">1.6. Automating the install using preseeding</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2535099">1.7. Debugging the installer</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="index.html#id2535150">2. D-I components or udebs</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="index.html#id2535252">2.1. Contents of a udeb</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2535308">2.2. Creating a udeb</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2535410">2.3. Library udebs</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="index.html#id2535520">3. Building installer images</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="index.html#id2535680">3.1. Requirements for building</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2535727">3.2. Build targets</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2535828">3.3. The build system explained</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2536220">3.4. Result of the build</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2536259">3.5. Library reduction</a></span></dt>
<dt><span class="sect2"><a href="index.html#id2536330">3.6. Using localudebs</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="index.html#id2536438">4. Conclusion</a></span></dt>
</dl>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id2534366"></a>1. Running Debian Installer</h2></div></div></div>
<p>
The examples in this section reflect the current status of the Installer, the Etch Beta 2 release, and are based on the CD-ROM and netboot installation methods for i386. The choice for i386 was made as this is most familiar to most users, but installations for other architectures is not structurally different<sup>[<a name="id2522005" href="#ftn.id2522005">1</a>]</sup>.

</p>
<p>

So what are the basic steps when the installer is run? In any installation five stages can be distinguished.

</p>
<div class="orderedlist"><ol type="1">
<li>
boot and initialization — setting up the installer so that it can load any additional components
  </li>
<li>
loading additional components — expanding the installer to its full functionality)
  </li>
<li>
network configuration (unless already done in stage 1)
  </li>
<li>
partitioning
  </li>
<li>
installing the target system
  </li>
</ol></div>
<p>

</p>
<p>

The first three stages are where the fundamental difference between installation methods can be seen. All components (udebs) used there need to be included in the initrd<sup>[<a name="id2522047" href="#ftn.id2522047">2</a>]</sup> with which the installer is booted.

</p>
<p>

The table below shows what components are involved in the first and second stage for the CD-ROM and netboot installation methods and also shows where these differ.

</p>
<div class="informaltable"><table border="1">
<colgroup>
<col align="center">
<col align="center">
<col align="center">
<col align="left">
</colgroup>
<thead><tr>
<th align="center">Stage</th>
<th align="center">CD-ROM</th>
<th align="center">NETBOOT</th>
<th align="left">Comments</th>
</tr></thead>
<tbody>
<tr>
<td align="center">-</td>
<td colspan="2" align="center">initrd-preseed</td>
<td align="left">Only if <code class="filename">/preseed.cfg</code> is present</td>
</tr>
<tr>
<td align="center">1</td>
<td colspan="2" align="center">localechooser</td>
<td align="left">Language/country/locale selection</td>
</tr>
<tr>
<td align="center">1</td>
<td colspan="2" align="center">kbd-chooser</td>
<td align="left">Keyboard selection</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">cdrom-detect</td>
<td align="center">eth-detect</td>
<td align="left">Hardware detection and setup</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"> </td>
<td align="center">netcfg</td>
<td align="left">Network configuration</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">file-preseed</td>
<td align="center">network-preseed</td>
<td align="left">If selected at boot prompt</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"> </td>
<td align="center">choose-mirror</td>
<td align="left">Mirror selection</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">load-cdrom (anna)</td>
<td align="center">download-installer (anna)</td>
<td align="left">Retrieve and unpack additional components</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">eth-detect</td>
<td align="center"> </td>
<td align="left">Hardware detection and setup</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">netcfg</td>
<td align="center"> </td>
<td align="left">Network configuration</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">choose-mirror</td>
<td align="center"> </td>
<td align="left">Mirror selection (sometimes needed for stage 4)</td>
</tr>
</tbody>
</table></div>
<p>

The remainder of the installation is basically the same for all installation methods.

</p>
<div class="informaltable"><table border="1">
<colgroup>
<col align="center">
<col align="center">
<col align="left">
</colgroup>
<thead><tr>
<th align="center">Stage</th>
<th align="center"> </th>
<th align="left">Comments</th>
</tr></thead>
<tbody>
<tr>
<td align="center">4</td>
<td align="center">hw-detect</td>
<td align="left">Additional hardware detection</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">partman</td>
<td align="left">Partitioning, file system creation and mount point selection</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">tzsetup</td>
<td align="left">Time zone selection</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">clock-setup</td>
<td align="left">Configure for hardware clock set to UTC or local time zone</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">user-setup</td>
<td align="left">Set up root and normal user accounts</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">base-installer</td>
<td align="left">Base system (debootstrap) &amp; kernel installation</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">apt-setup</td>
<td align="left">APT configuration in the target system (sources.list)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">pkgsel</td>
<td align="left">Select and install additional packages (tasksel)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">grub/lilo-installer; nobootloader</td>
<td align="left">Boot loader installation</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">prebaseconfig<sup>a)</sup>
</td>
<td align="left">Finish up the installation and reboot</td>
</tr>
</tbody>
</table></div>
<p>
<sup>a)</sup> Will soon be renamed to <code class="classname">finish-install</code>. The name “<span class="quote"><code class="classname">prebaseconfig</code></span>” no longer makes any sense as <code class="classname">base-config</code> was obsoleted with Etch Beta 2.
</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2476306"></a>1.1. Installation methods</h3></div></div></div>
<p>

The installer supports a lot of different installation methods and in some cases installation methods can be creatively combined. The definition of an installation method is based on the following questions.

</p>
<div class="itemizedlist"><ul type="disc">
<li>
How is the installer booted?
 </li>
<li>
From where are additional udebs retrieved?
 </li>
<li>
From where are packages needed to install the base system retrieved?
 </li>
<li>
From where are packages needed to install tasks retrieved<sup>[<a name="id2476331" href="#ftn.id2476331">3</a>]</sup>?
 </li>
</ul></div>
<p>

</p>
<p>

The table below shows the answers to these questions for the most common installation methods.

</p>
<div class="informaltable"><table border="1">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Method</th>
<th align="left">Boot</th>
<th align="left">Udebs</th>
<th align="left">Base system</th>
<th align="left">Tasks</th>
</tr></thead>
<tbody>
<tr>
<td align="left">netboot</td>
<td align="left">network (TFTP server)</td>
<td align="left">network</td>
<td align="left">network</td>
<td align="left">network</td>
</tr>
<tr>
<td align="left">mini.iso</td>
<td align="left">CD</td>
<td align="left">network</td>
<td align="left">network</td>
<td align="left">network</td>
</tr>
<tr>
<td align="left">businesscard CD</td>
<td align="left">CD</td>
<td align="left">CD</td>
<td align="left">network</td>
<td align="left">network</td>
</tr>
<tr>
<td align="left">netinst CD</td>
<td align="left">CD</td>
<td align="left">CD</td>
<td align="left">CD</td>
<td align="left">network</td>
</tr>
<tr>
<td align="left">full CD/DVD</td>
<td align="left">CD</td>
<td align="left">CD</td>
<td align="left">CD</td>
<td align="left">CD (+ network)</td>
</tr>
<tr>
<td align="left">hd-media<sup>a)</sup>
</td>
<td align="left">harddisk/USB stick</td>
<td align="left">CD image</td>
<td align="left">CD image/network</td>
<td align="left">CD image/network</td>
</tr>
<tr>
<td align="left">floppy (net)</td>
<td align="left">boot/root/net-drivers</td>
<td align="left">network</td>
<td align="left">network</td>
<td align="left">network</td>
</tr>
<tr>
<td align="left">floppy (cd)<sup>a)</sup>
</td>
<td align="left">boot/root/cd-drivers</td>
<td align="left">CD</td>
<td align="left">CD/network</td>
<td align="left">CD/network</td>
</tr>
</tbody>
</table></div>
<p>

<sup>a)</sup> Whether packages for the base system and tasks are retrieved from CD (image) or the network depends on the type of CD used in combination with these boot methods.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2468398"></a>1.2. The boot process</h3></div></div></div>
<p>
The boot process for the installer is similar to the boot of a regular system. A bootloader (in some cases the system's firmware) is responsible for loading the kernel and loading the initrd after which init is started. The boot process can be debugged by adding the <strong class="userinput"><code>BOOT_DEBUG</code></strong> parameter.

</p>
<p>

It is possible to pass additional kernel and boot parameters. Kernel parameters are sometimes needed to get non-conformant hardware supported, or to install from serial console instead of an attached keyboard/display.

</p>
<p>

Boot parameters can also be used to influence the installer itself. More about this in the section on preseeding.

</p>
<p>

The boot process is currently quite complex as it needs to support several generations of linux:

</p>
<div class="itemizedlist"><ul type="disc">
<li>
2.2, 2.4 and 2.6 kernels with devfs, all subtly different
 </li>
<li>
2.6 kernels with udev; several generations, both with and without hotplug
 </li>
</ul></div>
<p>

</p>
<p>

The following enumeration gives an overview of the main steps in the boot process.

</p>
<div class="variablelist"><dl>
<dt><span class="term">1) <span><strong class="command">/init</strong></span> (initramfs) or <span><strong class="command">/sbin/init</strong></span> (initrd)</span></dt>
<dd><p>
Sets up initial environment (<code class="filename">/proc</code>, <code class="filename">/dev</code>; run <span><strong class="command">udev</strong></span>)
    </p></dd>
<dt><span class="term">2) <span><strong class="command">busybox init</strong></span></span></dt>
<dd>
<p>
<code class="filename">/etc/inittab</code> is parsed; this contains:

</p>
<div class="itemizedlist"><ul type="disc">
<li><code class="literal">::sysinit:/sbin/debian-installer-startup</code></li>
<li><code class="literal">::respawn:/sbin/debian-installer</code></li>
<li>
init for VT2 (busybox shell), VT3 (<code class="filename">/var/log/messages</code>), VT4 (<code class="filename">/var/log/syslog</code>)
 </li>
</ul></div>
<p>

    </p>
</dd>
<dt><span class="term">3) <span><strong class="command">/sbin/debian-installer-startup</strong></span></span></dt>
<dd>
<p>
This is a run-parts like script that executes or sources scripts in <code class="filename">/lib/debian-installer-startup.d</code>. The main functions that are performed are: 

</p>
<div class="itemizedlist"><ul type="disc">
<li>
mount <code class="filename">devfs</code> and <code class="filename">sysfs</code> if appropriate
 </li>
<li>
run <span><strong class="command">udev</strong></span>/<span><strong class="command">hotplug</strong></span>
</li>
<li>
load acpi modules
 </li>
<li>
start syslog
 </li>
<li>
check available memory and, depending on preset limits, enable a lowmem mode if needed
 </li>
<li>
load any debconf templates present in the initrd
 </li>
<li>
parse boot parameters to look for debconf patterns (<strong class="userinput"><code>&lt;<em class="replaceable"><code>component</code></em>&gt;/&lt;<em class="replaceable"><code>template</code></em>&gt;=&lt;<em class="replaceable"><code>value</code></em>&gt;</code></strong>) and set these in the debconf database
 </li>
<li>
detect the type of console that is used
 </li>
<li>
load framebuffer modules
 </li>
<li>
detect if the installer should run in rescue mode
 </li>
</ul></div>
<p>

    </p>
</dd>
<dt><span class="term">4) <span><strong class="command">/sbin/debian-installer</strong></span></span></dt>
<dd>
<p>
This is a run-parts like script that sources scripts in <code class="filename">/lib/debian-installer.d</code>. The main functions that are performed are:

</p>
<div class="itemizedlist"><ul type="disc">
<li>
detect if a framebuffer device is available
 </li>
<li>
initialize the console (blanking, UTF-8)
 </li>
<li>
select which debconf frontend is to be used (text, newt, gtk)
 </li>
<li>
start <code class="classname">main-menu</code> (see next section)
 </li>
<li>
halt or reboot the system (after <code class="classname">main-menu</code> exits)
 </li>
</ul></div>
<p>

    </p>
</dd>
</dl></div>
<p>

Scripts in <code class="filename">/lib/debian-installer(-startup).d</code> can be architecture specific.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2468709"></a>1.3. The Debian Installer Menu</h3></div></div></div>
<p>
The component <code class="classname">main-menu</code> drives the rest of the installation. It is responsible both for dynamically assembling the menu and for executing components when they are selected. Note that the menu is only actually visible when installing at low or medium debconf priority. At higher priorities it is still there, but it will automatically execute the next component without showing the menu to the user.

</p>
<p>

In some situations the debconf priority is automatically changed. It is reduced when the execution of a component fails, or when the user uses the <strong class="userinput"><code>&lt;go back&gt;</code></strong> button to back out all the way to the menu. In these cases it will also be increased back to the original level when the next component executed finishes successfully.

</p>
<p>

An important characteristic of udebs is that execution of their postinst scripts is delayed. On installation udebs are only unpacked; the execution of the postinst is done by main-menu and is actually what happens when a component is selected in the menu. In other words, main-menu can be said to be responsible for “<span class="quote">configuring</span>” the udeb.

</p>
<p>

For a component to be included in the menu, it needs to have an <code class="literal">Installer-Menu-Item</code> line in the <code class="classname">dpkg</code> status file (<code class="filename">/var/lib/dpkg/status</code>). The order of components in the menu is determined primarily by its dependencies; the menu item number is used only where the order for two or more components cannot be resolved by dependencies alone.

</p>
<p>

Provides can be used to define virtual states which other components can depend on, as shown in the next example.

</p>
<div class="informalexample"><pre class="screen">
Package: netcfg
Status: install ok installed
Version: 1.23
Provides: configured-network
Depends: libc6 (&gt;= 2.3.5-1), libdebconfclient0, libdebian-installer4 (&gt;= 0.37),
         dhcp-client-udeb | dhcp3-client-udeb | pump-udeb, libiw28-udeb,
         cdebconf-udeb, ethernet-card-detection
Description: Configure the network
Installer-Menu-Item: 18

Package: choose-mirror
Status: install ok unpacked
Version: 1.19
Depends: libc6 (&gt;= 2.3.5-1), libdebconfclient0, libdebian-installer4 (&gt;= 0.38),
         configured-network
Description: Choose mirror to install from
Installer-Menu-Item: 23
</pre></div>
<p>

</p>
<p>

This example also shows that netcfg has been run successfully (“<span class="quote">installed</span>”) while mirror selection has not yet taken place (“<span class="quote">unpacked</span>”).

</p>
<p>

Some components are included in the menu but are not run by default. These components have a menu number higher than prebaseconfig. Examples are components that allow to change the debconf priority, to save debug logs, to check the integrity of a CD-ROM or to abort the installation.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2534702"></a>1.4. Hooks provide additional flexibility</h3></div></div></div>
<p>
At certain points in the installation, components provide run-parts like execution of scripts. This allows other components to just drop scripts there so that commands can be run at that point in the installation, even though the postinst for the component itself is run earlier or later (if the component even has a postinst).

</p>
<p>

The main hooks are:

</p>
<div class="variablelist"><dl>
<dt><span class="term"><code class="filename">/usr/lib/base-installer.d</code></span></dt>
<dd><p>
Run by base-installer before debootstrap is started.
    </p></dd>
<dt><span class="term"><code class="filename">/usr/lib/post-base-installer.d</code></span></dt>
<dd><p>
Run by base-installer just before kernel selection/installation.
    </p></dd>
<dt><span class="term"><code class="filename">/usr/lib/prebaseconfig.d</code></span></dt>
<dd><p>
Run by prebaseconfig.
    </p></dd>
</dl></div>
<p>

</p>
<p>

Other, more special purpose hooks are <code class="filename">/usr/lib/apt-setup/generators</code>, <code class="filename">/lib/main-menu.d</code> and <code class="filename">/lib/rescue.d</code>.

</p>
<p>

Besides these general hooks, partman is basically structured as one big collection of hooks where partman components all drop their own scriptlets to extend partman's functionality. The most noteworthy of these hooks is <code class="filename">/lib/partman/finish.d</code> as some bootloaders drop scripts there to add checks that ensure the selected partitioning scheme conforms to their requirements.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2534804"></a>1.5. Some special tools</h3></div></div></div>
<p>
The installer has some special commands which can be used in postinst or preseeding scripts:

</p>
<div class="variablelist"><dl>
<dt><span class="term"><span><strong class="command">anna-install</strong></span></span></dt>
<dd><p>
Used to install additional, non-standard d-i components (udebs). It will check if <code class="classname">anna</code> has already been run. If it has, the component is unpacked immediately; if it has not, it will be scheduled for installation when <code class="classname">anna</code> is run.
    </p></dd>
<dt><span class="term"><span><strong class="command">apt-install</strong></span></span></dt>
<dd><p>
Performs the same function for normal packages and installs them in the target system. Packages will either be installed immediately (if called after base-installer) or scheduled for installation as one of the “<span class="quote">extra</span>” packages installed near the end of base-installer's postinst script.
    </p></dd>
<dt><span class="term"><span><strong class="command">log-output</strong></span></span></dt>
<dd><p>
Allows to run a command and redirect its output (either <code class="filename">stdout</code> or <code class="filename">stderr</code> or both) to <code class="filename">/var/log/syslog</code>.
    </p></dd>
<dt><span class="term"><span><strong class="command">in-target</strong></span></span></dt>
<dd><p>
Allows to run a command in a chroot on <code class="filename">/target</code> with the chroot being set up for more demanding operations. For example, <code class="filename">proc</code> and <code class="filename">sysfs</code> are mounted and a <code class="filename">policy-rc.d</code> is created. Can obviously only be used after the base system has been set up.
    </p></dd>
</dl></div>
<p>

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2534942"></a>1.6. Automating the install using preseeding</h3></div></div></div>
<p>
There are three preseed methods that are currently supported:
</p>
<div class="variablelist"><dl>
<dt><span class="term"><span class="emphasis"><em>initrd preseeding</em></span></span></dt>
<dd><p>
The preseed file <code class="filename">/preseed.cfg</code> needs to be present in the initrd. It is read as part of the <span><strong class="command">debian-installer-startup</strong></span> processing.
    </p></dd>
<dt><span class="term"><span class="emphasis"><em>file preseeding</em></span></span></dt>
<dd><p>
Triggered by the presence of the <strong class="userinput"><code>preseed/file</code></strong> boot parameter.
    </p></dd>
<dt><span class="term"><span class="emphasis"><em>network preseeding</em></span></span></dt>
<dd><p>
Triggered by the presence of the <strong class="userinput"><code>preseed/url</code></strong> boot parameter. In versions later than Etch Beta 2 it is also possible to trigger this from the DHCP server.
    </p></dd>
</dl></div>
<p>

Which of these methods is available depends on the installation method.

</p>
<p>

The main purpose of preseeding is to set default values for debconf questions. Note that it makes no sense when using file or network preseeding to preseed values for questions that are asked <span class="emphasis"><em>before</em></span> the preseed file is parsed.

</p>
<p>

Besides offering the option to set default values for debconf questions, preseeding also makes it possible to run scripts at two distinct moments using <strong class="userinput"><code>preseed/early_command</code></strong> and <strong class="userinput"><code>preseed/late_command</code></strong>. The <strong class="userinput"><code>early_command</code></strong> is executed immediately after the preseed file is parsed (only for file and network preseeding); the <strong class="userinput"><code>late_command</code></strong> is executed as part of the <span><strong class="command">prebaseconfig</strong></span> component.

</p>
<p>

These scripts can be made as complex as you like. One option is to use them to install additional packages on the target system (using <span><strong class="command">apt-install</strong></span>). The <strong class="userinput"><code>early_command</code></strong> could be used to install additional d-i components (using <span><strong class="command">anna-install</strong></span>) or to install scripts in the various hook script directories (if commands need to be executed at a specific point in the installation).

</p>
<p>

Additional information about preseeding is available in an appendix of the Installation Guide.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535099"></a>1.7. Debugging the installer</h3></div></div></div>
<p>
Because most of the installer is scripted, it is fairly easy to debug most problems by adding a <strong class="userinput"><code>set -x</code></strong> in the correct place. The obvious place to start is the postinst of the component you want to debug. The output will appear in <code class="filename">/var/log/syslog</code>, which can most easily be viewed by starting the internal webserver from the “<span class="quote">Save debug logs</span>” menu option (after the network has been configured).

</p>
<p>

For components written in C debugging is a bit harder. Options are to use the strace udeb (add it to a custom image if needed) or to create a custom version of a component with added debug statements in the source and use that.

</p>
<p>

For debugging, you will probably want to control when components are started. Booting the installer with <strong class="userinput"><code>install debconf/priority=medium</code></strong> is a good way to achieve that. It will make sure the menu is displayed before a new component is started.

</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id2535150"></a>2. D-I components or udebs</h2></div></div></div>
<p>
A udeb (or micro-deb) is a special kind of Debian package. Technically udebs are very similar to regular packages: you can look at their contents using <span><strong class="command">dpkg -c</strong></span>, and extract them using <span><strong class="command">dpkg -x</strong></span> and <span><strong class="command">dpkg -e</strong></span>.

</p>
<p>

The main difference is that a lot of policy requirements are waived. For example, a udeb does not contain a changelog, licence, manpages or md5sum<sup>[<a name="id2535182" href="#ftn.id2535182">4</a>]</sup>. Reason is to minimize size which is important as the installation completely takes place in RAM, with swap only becoming available after stage 4 of the installation (partitioning).

</p>
<p>

Another important difference is that udebs are not really meant to be uninstalled or upgraded.

</p>
<p>

The relaxed policy requirements make one of the reasons that udebs should to be installed on a normal system. The other reason being that it just doesn't make sense and it's likely to break things.

</p>
<p>

Two special classes of udebs should be mentioned here. However, covering these in detail is outside the scope of this paper.
</p>
<div class="variablelist"><dl>
<dt><span class="term">Kernel image and kernel module udebs</span></dt>
<dd><p>
Kernel udebs are built basically by repackaging a regular kernel-image package. Reason is again to reduce memory usage: not all modules included in a kernel-image package are needed during an installation. Also, different modules are needed in the initrd for different installation methods, remaining modules can either be loaded later or optionally (by manual selection or through dependencies). The package <code class="classname">kernel-wedge</code> contains the toolset used to reorganize a kernel-image package into multiple kernel (module) udebs.
    </p></dd>
<dt><span class="term">Partman and its components</span></dt>
<dd><p>
Partman has a very specific structure and requires a fairly strict conformance to this structure for udebs that extend its functionality.
    </p></dd>
</dl></div>
<p>

</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535252"></a>2.1. Contents of a udeb</h3></div></div></div>
<p>
For components that are included in the main menu, the udeb will at least contain:

</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
a postinst
 </p></li>
<li>
<p>
a debconf template that contains the description for the main menu:

</p>
<div class="informalexample"><pre class="screen">
debian-installer/&lt;component&gt;/title
Type: text
_Description: Configure time zone
</pre></div>
<p>

 </p>
</li>
</ul></div>
<p>

</p>
<p>

Other things like additional debconf templates, C programs, hook scripts can be added as needed.

</p>
<p>

A special type of control file worth mentioning is the <code class="filename">isinstallable</code> file. If a script with this name is present in <code class="filename">/var/lib/dpkg/info</code> for a component, the main menu will run this script and only include the component in the menu if the script exits 0.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535308"></a>2.2. Creating a udeb</h3></div></div></div>
<p>
Creating a udeb is not all that hard, especially if you use <code class="classname">debhelper</code>. <code class="classname">debhelper</code> knows the special properties of a udeb and will do the right thing by default at build time. That is, if you don't forget to tell it you are creating a udeb.

</p>
<p>

The example below shows the <code class="filename">debian/control</code> file for a udeb that is supposed to be included in the main menu. Note the special section.

</p>
<div class="informalexample"><pre class="screen">
Source: kbd-chooser
Section: debian-installer
Priority: optional
Maintainer: Debian Install System Team &lt;debian-boot@lists.debian.org&gt;
Uploaders: [...]
Build-Depends: debhelper (&gt;= 5.0.22), libdebian-installer4-dev (&gt;= 0.41), po-debconf (&gt;= 0.5.0), flex | flex-old , bison, libdebconfclient0-dev (&gt;= 0.49)

Package: kbd-chooser
Architecture: i386 amd64 powerpc alpha hppa sparc [...]
XC-Package-Type: udeb
Depends: ${shlibs:Depends}, ${misc:Depends}, console-keymaps
Description: Detect a keyboard and select layout
XB-Installer-Menu-Item: 12
</pre></div>
<p>

The line <code class="literal">XC-Package-Type</code> tells <code class="classname">debhelper</code> to treat the package as a udeb. The <code class="literal">XB-Installer-Menu-Item</code> is added in the control file for the udeb and will eventually end up in the <code class="classname">dpkg</code> status file to help <code class="classname">main-menu</code> figure out that this udeb should be included in the menu and in what order<sup>[<a name="id2535384" href="#ftn.id2535384">5</a>]</sup>.

Packaging a udeb becomes a bit harder if it is derived from a regular package but needs to be compiled with different compiler options (e.g. some features disabled or a different optimization).

</p>
<p>

The main thing to always keep in mind when creating a udeb is size. It is very important to keep size as minimal as possible. This includes using tabs instead of spaces when indenting in scripts and not being too verbose in comments.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535410"></a>2.3. Library udebs</h3></div></div></div>
<p>
A major recent improvement is the addition of “<span class="quote">package type</span>” support in shlibs files for libraries. This allows <span><strong class="command">dpkg-dev</strong></span> and <code class="classname">debhelper</code> to automatically set correct dependencies on library udebs when a d-i component that depends on them is built.

</p>
<p>

For example, the regular binary package <code class="classname">zlib1g</code> now has the following lines in its shlibs control file:
</p>
<div class="informalexample"><pre class="screen">
libz 1 zlib1g (&gt;= 1:1.2.1)
udeb: libz 1 zlib1g-udeb (&gt;= 1:1.2.1)
</pre></div>
<p>

</p>
<p>

The second line is specific to the package type “<span class="quote">udeb</span>”. This alternative line is used when <span><strong class="command">dpkg-shlibdeps</strong></span> is called with the <span><strong class="command">-tudeb</strong></span> option; <span><strong class="command">dh_shlibdeps</strong></span> will automatically add this option when processing a udeb.

</p>
<p>

Generating the extra <code class="literal">udeb:</code> lines is supported by <span><strong class="command">dh_makeshlibs</strong></span> if the <span><strong class="command">--add-udeb="&lt;udeb name&gt;"</strong></span> option is used. For example, the <code class="filename">debian/rules</code> file for <code class="classname">libusb</code> contains the following line:
</p>
<div class="informalexample"><pre class="screen">
dh_makeshlibs -V -s --add-udeb="libusb-0.1-udeb"
</pre></div>
<p>

</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id2535520"></a>3. Building installer images</h2></div></div></div>
<p>
This paper will only provide an introduction to building installer images using existing definitions. The README in <code class="filename">installer/build</code> in the SVN repository contains more detailed information about the build system and how to modify existing or define new images.

</p>
<p>

An image consists of:

</p>
<div class="itemizedlist"><ul type="disc">
<li>
a kernel;
 </li>
<li>
an initrd, which is basically a collection of unpacked udebs;
 </li>
<li>
in some cases a boot loader and/or configuration files used for booting.
 </li>
</ul></div>
<p>

</p>
<p>

Most d-i images are “<span class="quote">ready for use</span>”. The exception are the cdrom images which form only the base (kernel and initrd) for creating the actual CD or DVD images. The package used for creating the CD/DVD images is <code class="classname">debian-cd</code>.

</p>
<p>

On some architectures there is one CD image that <span class="emphasis"><em>is</em></span> ready for use: the <code class="filename">mini.iso</code> that is produced as a by-product of the netboot target. Reason is that this image does not really support installing from CD, it just allows booting from CD but retrieves all additional udebs and packages over the network.

</p>
<p>

It is important to distinguish between building images for release and building images for development/testing use.

</p>
<p>

A release build is done, as for other packages that are to be uploaded, from the <code class="filename">installer</code> directory using <span><strong class="command">debian/rules</strong></span>. This will create a binary package (needed for uploading) containing some documentation, but the important bit is a tarball containing all installer images. After the upload this tarball needs BYHAND processing<sup>[<a name="id2535606" href="#ftn.id2535606">6</a>]</sup> by FTP-masters before the buildds will pick up the upload for other architectures.

</p>
<p>

Building images for development and testing is done from the <code class="filename">installer/build</code> directory<sup>[<a name="id2535632" href="#ftn.id2535632">7</a>]</sup> using <span><strong class="command">fakeroot make &lt;<em class="replaceable"><code>target</code></em>&gt;</strong></span>.

</p>
<p>

An important difference between release and development builds is that release builds will use udebs for the same suite as the target system being installed, while development builds will by default install testing, but use udebs from unstable<sup>[<a name="id2535663" href="#ftn.id2535663">8</a>]</sup>. This allows to mostly avoid the occasional breakage of the base system and tasks in unstable while using the most recent udebs.

</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535680"></a>3.1. Requirements for building</h3></div></div></div>
<p>
For both release and development builds the build dependencies as listed in <code class="filename">installer/debian/control</code> need to be satisfied.

</p>
<p>

To build installer images from SVN trunk, your build machine needs to be running unstable or you need to set up a sid chroot to build in. (To build images from the sarge branch of the repository, the build machine needs to run Sarge.)

</p>
<p>

During the build, the needed udebs will be retrieved from a mirror. By default this mirror is based on your <code class="filename">/etc/apt/sources.list</code> (see the generated file <code class="filename">build/sources.list.udeb</code>). To use a different source, create a file <code class="filename">sources.list.udeb.local</code>.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535727"></a>3.2. Build targets</h3></div></div></div>
<p>
To see which targets are available, run <span><strong class="command">make</strong></span>. This will result in a list of 135 targets, most of which are not really relevant. A more useful list can be obtained with <span><strong class="command">make | grep ^build</strong></span>. The table below has the most often used targets for i386.

</p>
<div class="informaltable"><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td><strong class="userinput"><code>build_all</code></strong></td>
<td>Builds all images</td>
</tr>
<tr>
<td><strong class="userinput"><code>build_cdrom_isolinux</code></strong></td>
<td>Builds the cdrom images (both 2.4 and 2.6)</td>
</tr>
<tr>
<td><strong class="userinput"><code>build_netboot</code></strong></td>
<td>Builds the netboot images (both 2.4 and 2.6) and the mini.iso</td>
</tr>
<tr>
<td><strong class="userinput"><code>reallyclean</code></strong></td>
<td>Completely cleans the build environment</td>
</tr>
</tbody>
</table></div>
<p>

The <strong class="userinput"><code>reallyclean</code></strong> target is often needed when changes are made between builds because otherwise udebs or information may be retrieved from temporary or cache directories and the changes will not take effect. The <code class="filename">rebuild_*</code> targets clean some of this, but not always enough.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2535828"></a>3.3. The build system explained</h3></div></div></div>
<p>
The easiest way to start is with the purpose of the subdirectories in the <code class="filename">installer/build</code> directory.

</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
<code class="filename">config</code>: defines the available targets (per architecture)
 </p></li>
<li><p>
<code class="filename">pkg-lists</code>: defines which udebs are included in an image (per image type)
 </p></li>
<li><p>
<code class="filename">boot</code>: contains configuration files and make targets used to make images bootable
 </p></li>
<li><p>
<code class="filename">localudebs</code>: allows to use (versions of) udebs not available on the mirror you use
 </p></li>
<li><p>
<code class="filename">util</code>: contains helper scripts called from the Makefile
 </p></li>
</ul></div>
<p>

Two files containing important configuration info are <code class="filename">config/dir</code> and <code class="filename">config/common</code>. However, normally there should be no need to modify any of the variables defined in these files.

</p>
<p>

Both the <code class="filename">config</code> and <code class="filename">pkg-lists</code> directories have a tree structure with general configuration defined in the root and more specific configuration defined in branches and leaves. Branches are defined in directories that have the same name as a config file on the higher level. The <code class="filename">config</code> directory contains makefile snippets.

</p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id2535946"></a>3.3.1. config</h4></div></div></div>
<p>
For example, the definition for i386 images starts with <code class="filename">config/i386.cfg</code> which, besides the current kernel versions, defines the media supported with the line:

</p>
<div class="informalexample"><pre class="screen">
MEDIUM_SUPPORTED = cdrom netboot floppy hd-media
</pre></div>
<p>

</p>
<p>

These media correspond to the main targets for i386 and are further defined in <code class="filename">config/i386</code>. The <code class="filename">netboot.cfg</code> file in that directory contains, amongst others, the following three lines:

</p>
<div class="informalexample"><pre class="screen">
FLAVOUR_SUPPORTED = "" 2.6
MEDIA_TYPE = netboot image
EXTRATARGETS = build_netboot_2.6
</pre></div>
<p>

</p>
<p>

This defines that the netboot image has two flavors: the default one (using a 2.4 kernel) and an one using a 2.6 kernel, which is further defined in the <code class="filename">config/i386/netboot/2.6.cfg</code> file where the default values of the variables for the kernel version are overruled.

</p>
<p>

The files in config are processed recursively to dynamically generate the build targets, so in this example you get a netboot, a <strong class="userinput"><code>netboot_2.6</code></strong> target and targets for the other media. Building is also recursive, so calling the netboot target will automatically build both the <strong class="userinput"><code>netboot</code></strong> and <strong class="userinput"><code>netboot_2.6</code></strong> images.

</p>
<p>

The structure of the config files can get quite complex and it can be hard to keep track of the exact role of the different variables set in them.

</p>
</div>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id2536038"></a>3.3.2. pkg-lists</h4></div></div></div>
<p>
The list of udebs to be included in an image is built by the <span><strong class="command">util/pkg-list</strong></span> script based on definitions in the <code class="filename">pkg-lists</code> directory. Again, processing is can be quite complex. Let's take the netboot target for i386 as an example to explain it.

</p>
<p>

First the file <code class="filename">pkg-lists/netboot/i386.cfg</code> is considered and all udebs listed in it are added. Some example lines from that file:

</p>
<div class="informalexample"><pre class="screen">
#include "discover"
console-keymaps-at
console-keymaps-usb
usb-discover [2.4]
socket-modules-${kernel:Version} ?
acpi-modules-${kernel:Version} [2.6]
</pre></div>
<p>

</p>
<p>

The variable <code class="literal">${kernel:Version}</code> is expanded to match the package name of the udeb based on the kernel version and flavor. If the name of a udebs is followed by “<span class="quote">[2.4]</span>” or “<span class="quote">[2.6]</span>”, it is only included if the kernel major version for the image being built matches. If it is followed by a question mark it is skipped if the package is not available (without the question mark an error would be generated).

</p>
<p>

The first line with the <code class="literal">#include</code> results in the file <code class="filename">pkg-lists/discover</code> being processed next in the same way.

</p>
<p>

The <span><strong class="command">pkg-list</strong></span> script will also always look for the presence of files named <code class="filename">common</code> and <code class="filename">local</code> and thus <code class="filename">pkg-lists/netboot/common</code> is processed next. This file exists and lists a number of udebs that belong in any netboot image, independent of the architecture. This file also contains two include directives:

</p>
<div class="informalexample"><pre class="screen">
#include "base"
#include "kernel"
</pre></div>
<p>

</p>
<p>

Thus, udebs listed in <code class="filename">pkg-lists/base</code> (containing udebs common to all images) and <code class="filename">pkg-lists/kernel</code> (included in all bootable images) are also processed.

</p>
<p>

The file <code class="filename">pkg-lists/netboot/local</code> does not normally exist as it is intended for the inclusion of non-standard udebs. It is also very useful for testing as it can be used to temporarily add udebs not normally included without teh need to modify the regular files.

</p>
<p>

Finally, the script will check for <code class="filename">pkg-lists/local</code> and <code class="filename">pkg-lists/exclude</code>. The latter exists and contains some udebs otherwise pulled in by dependencies, but that should not be included because of library reduction, which is covered in the next section. Note that the exclusion if not triggered by the file name, but rather by the dash after the name of the udebs.

</p>
<p>

To see how the package list is built for a particular image, set <code class="code">my $debug=1;</code> in the <span><strong class="command">util/pkg-list</strong></span> script.

</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2536220"></a>3.4. Result of the build</h3></div></div></div>
<p>
If the build is successful, you will find the images under the <code class="filename">build/dest</code> directory. Depending on the type of build you will also find manifest and log files there.

</p>
<p>

Before the image is created, its contents are assembled in the directory <code class="filename">build/tmp/&lt;<em class="replaceable"><code>target</code></em>&gt;</code>. The <code class="filename">tree</code> subdirectory there contains the full contents of the initrd; other subdirectories are used for different purposes.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2536259"></a>3.5. Library reduction</h3></div></div></div>
<p>
Library reduction (recompiling a library leaving out the code for unused symbols) is used as yet another method to minimize the size of initrds. The downside of library reduction is that this requires the <code class="classname">dev</code> and <code class="classname">pic</code> packages for the libraries to be reduced to be installed on the build system which also means that their version needs to match the version of the libraries in the udebs.

</p>
<p>

The size reduction is most significant for libc (40%) and libm (90%). Other libraries that are reduced include libresolv, libslang and libnewt. The reduction is done by calling mklibs from the main Makefile.

</p>
<p>

As only the executables that are included in an image are taken into account during the library reduction, we have provide for executables in components that are installed later as they would fail if they use symbols that have been taken out.

</p>
<p>

This is the reason that the udebs containing reduced libraries are excluded in <code class="filename">pkg-lists/exclude</code> which results in the udeb not being listed in the <code class="filename">/var/lib/dpkg/status</code> file in the intrd. If no udebs that are installed later depend on the library, all is well. If a udeb that does depend on it is installed later, <code class="classname">anna</code> (or rather <span><strong class="command">udpkg</strong></span>) will see that the dependency is not satisfied, and will install the udeb so the unreduced library replaces the reduced version.

</p>
<p>

Note that library reduction is only done after unpacking udebs for inclusion in an image; the libraries included in udebs are never reduced.

</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id2536330"></a>3.6. Using localudebs</h3></div></div></div>
<p>
The <code class="filename">localudebs</code> directory allows to use a different version of udebs than is available from the mirror you use. This can be used to test a new version of a udeb or to run the installer with a debug version of a udeb. It can also be used to build an image with a custom udeb.

</p>
<p>

To use a local udeb, just copy it into the directory. A <code class="filename">Packages</code> file will be generated automatically. Your udeb should have a version equal to or greater than the udeb currently on the mirror you use.

</p>
<p>

Note that local udebs will only be included in the image if the udeb would be included in a normal build too. So it has to be selected by the <span><strong class="command">pkg-list</strong></span> script. Create a <code class="filename">pkg-lists/local</code> or <code class="filename">pkg-lists/&lt;<em class="replaceable"><code>image</code></em>&gt;/local</code> to add udebs to the image that would not normally be included.

</p>
<p>

Some things to keep in mind when using localudebs.

</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
If you add an extra udeb, its dependencies will be included too. If those dependencies include virtual udebs, the result is not always what you'd expect.
 </p></li>
<li><p>
Adding extra udebs will increase the size of the initrd; some architectures have limits for initrd size.
 </p></li>
<li>
<p>
If you use a <code class="filename">sources.list.udeb.local</code>, make sure to add as the first line:

</p>
<div class="informalexample"><pre class="screen">
deb copy:&lt;<em class="replaceable"><code>path-from-root-to</code></em>&gt;/installer/build/ localudebs/
</pre></div>
<p>
 
 </p>
</li>
<li><p>
Don't forget to clean up after you're finished.
 </p></li>
</ul></div>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id2536438"></a>4. Conclusion</h2></div></div></div>
<p>
Hopefully this paper will help make Debian Installer more accessible to new developers. If you have any suggestions to improve this document, please mail them to the debian-boot list or the author. The intention of the author is to use this paper as the basis for a d-i developers reference.

</p>
<p>

For any kind of work on Debian Installer, you should check out the d-i SVN repository on alioth: 
</p>
<div class="informalexample"><pre class="screen">
$ svn co svn+ssh://svn.debian.org/svn/d-i/trunk
</pre></div>
<p>

</p>
<p>

Subscription to the debian-boot list is recommended. To request commit access to the repository, please send a mail to that list.

</p>
<p>

Some additional development oriented documentation can be found in the repository under <code class="filename">installer/doc/devel</code> or in <code class="filename">README</code> files included with the source for various components.

</p>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id2522005" href="#id2522005">1</a>] </sup>
Some architectures currently do not use partman for partitioning, file system creation and mount point selection but instead use other components. Some architectures also use specific additional components as part of their default installation. However, this does not make them structurally different.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2522047" href="#id2522047">2</a>] </sup>
With one exception. In floppy disk based installations, the initrd does not contain all needed components for stage 2, but it does have the ability to load additional components that belong to stage one or are needed for stage 2 from additional floppy disks.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2476331" href="#id2476331">3</a>] </sup>

The last question can also be rephrased as “<span class="quote">what source lines are set up in the <code class="filename">/etc/apt/sources.list</code> file for the target system</span>”.

</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2535182" href="#id2535182">4</a>] </sup>
Of course, the source package for a udeb <span class="emphasis"><em>does</em></span> need to contain a proper licence and changelog.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2535384" href="#id2535384">5</a>] </sup>
The file <code class="filename">installer/doc/devel/menu-item-numbers.txt</code> in the d-i SVN repository documents menu numbers currently in use.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2535606" href="#id2535606">6</a>] </sup>
This entails unpacking the tarball into the correct location on the master mirror server and creating/updating the correct symlinks. See for example <a href="http://ftp.debian.org/debian/dists/sid/main/installer-i386/" target="_top">http://ftp.debian.org/debian/dists/sid/main/installer-i386/</a>.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2535632" href="#id2535632">7</a>] </sup>
This includes the daily built images available from <a href="http://www.debian.org/devel/debian-installer" target="_top">http://www.debian.org/devel/debian-installer</a>. These are generated and uploaded from machines run by d-i porters using the daily-build script.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2535663" href="#id2535663">8</a>] </sup>
This is accomplished by including the <code class="filename">/installer/build/unstable.cfg</code> preseed file in the initrd.
</p></div>
</div>
</div>
<div class="navfooter"><hr></div>
</body>
</html>
