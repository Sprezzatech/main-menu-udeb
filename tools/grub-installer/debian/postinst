#! /bin/sh

set -e
. /usr/share/debconf/confmodule
#set -x

log=/var/log/messages

log() {
    echo "grub-installer: $@" >> $log
}

error() {
    log "error: $@"
}

info() {
    log "info: $@"
}

if apt-install grub ; then
	:
else
	log "Calling 'apt-install grub' failed"
	# Hm, unable to install grub into /target/, what should we do?
	db_input critical grub-installer/apt-install-failed || [ $? -eq 30 ]
	db_go
	db_get
	if [ true != "$RET" ] ; then
		exit 1
	fi
fi

if [ "$defaultbootdev" ] ; then
    db_subst grub-installer/bootdev bootdev "$defaultbootdev"
fi
db_input medium grub-installer/bootdev || [ $? -eq 30 ]
db_go

db_get grub-installer/bootdev
bootdev=$RET

log "Installing grub on '$bootdev'"

if chroot /target /sbin/grub-install "$bootdev" >> $log 2>&1 ; then
    :
else
    log "error: Running 'grub-install \"$bootdev\"' failed."
    db_subst grub-installer/grub-install-failed BOOTDEV "$bootdev"
    db_input critical grub-installer/grub-install-failed || [ $? -eq 30 ]
    db_go
    exit 1
fi

# Pipe from 'yes' to tell grub to create menu.lst when it is missing A
# better correct fix is to get update-grub to be able to run in
# noninteractive mode.  Newer versions of the grub package support
# '-y' for noninteractive installs.  This option should be used when
# the new grub is available in Sarge.
if chroot /target /usr/bin/yes | chroot /target /sbin/update-grub >> $log 2>&1 ; then
    :
else
    error "Running 'update-grub' failed." 1>&2
    db_input critical grub-installer/update-grub-failed || [ $? -eq 30 ]
    db_go
    exit 1
fi

(
    echo "postinst_hook = /sbin/update-grub"
    echo "postrm_hook   = /sbin/update-grub"
    echo "do_bootloader = no"
) >> /target/etc/kernel-img.conf
