#! /bin/sh -e

. /usr/share/debconf/confmodule

logfile=/var/log/messages

log() {
    logger -t kernel-installer "$@"
}
error() {
    log "error: $*"
}
warning() {
    log "warning: $*"
}
info() {
    log "info: $*"
}

# =================== Pick the kernel package =========================

# find all packages implementing 'kernel-image'.  Is there a better
# way? [pere 2003-02-16]

chroot="chroot /target"

db_progress START 0 5 kernel-installer/progress/title

db_progress INFO kernel-installer/progress/step_locate

# Fetch the current default
if db_get debian-installer/kernel/image && [ "$RET" ] ; then
    kernel="$RET"
fi

# the busybox  do not support 'uniq' and 'sort -r' at
# the moment [pere 2003-02-06]

kernel_list=/tmp/available_kernels.txt
kernel_update_list() {
    # Using 'uniq' to avoid listing the same kernel more then once.
    $chroot apt-cache search kernel-image | grep ^kernel-image | \
      cut -d" " -f1 | /target/usr/bin/uniq > $kernel_list
}

kernel_present() {
    if grep -q "^$1\$" $kernel_list ; then
	true
    else
	false
    fi
}

# Using 'sort -r' to get the newest kernel version at the start of the
# list (ie 2.4.20 above 2.2.20).  This is in conflict with getting the
# most generic architecture first (386 above 686).

kernel_update_list
kernels=`/target/usr/bin/sort -r $kernel_list| tr '\n' ',' | sed -e 's/,$//'`

info "Found kernels '$kernels'"

if [ "$kernels" ] ; then
    db_subst kernel-installer/which-kernel KERNELS "$kernels"
else
    db_subst kernel-installer/no-kernels-found KERNEL "$kernel"
    db_input critical kernel-installer/no-kernels-found || [ $? -eq 30 ]
    db_go
    db_progress STOP
    exit 1
fi

db_progress STEP 1
db_progress INFO kernel-installer/progress/step_select

# Try to make current rootskel setting the default, make sure it is
# available first.
if kernel_present "$kernel" ; then
    # Current selection is available, nothing to do
    :
else
    # Pick the first in the list
    kernel=`echo "$kernels" | cut -d, -f1`
fi

# Pick a good default choice, based on the available kernels and
# perhaps /proc/cpuinfo.
ARCH=`udpkg --print-architecture`

# Should this instead be located in small script fragments, named
# after their architecture?  Something like this:
#  [ -f /usr/lib/kernel-installer/$ARCH ] && . /usr/lib/kernel-installer/$ARCH
trykernel=
separate_pcmcia_modules=n
case "$ARCH" in
    i386*)
        version=2.4
	separate_pcmcia_modules=y
        MODEL=`grep 'model name' /proc/cpuinfo | cut -d: -f2`
	if dmesg | grep -q ^Processors:; then
	    CPUS=`dmesg | grep ^Processors: | cut -d: -f2`
	else
	    CPUS=1
	fi
	case "$MODEL" in 
	    " Intel(R) Pentium(R) 4"*)
		if test $CPUS -eq 1; then
		    trykernel=kernel-image-$version-686
		else
		    trykernel=kernel-image-$version-686-smp
		fi
		;;
	    " AMD Athlon(tm) Processor"*)
		if test $CPUS -eq 1; then
		    trykernel=kernel-image-$version-k7
		else
		    trykernel=kernel-image-$version-k7-smp
		fi
		;;
	    *)
		trykernel=kernel-image-$version-386
		;;
	esac
        ;;
    sparc)
        version=2.4.21
	MODEL=`uname -m`
	CPUS=`grep 'ncpus probed' /proc/cpuinfo | cut -d: -f2`
	case "$MODEL" in
	    sparc)
		if [ "$CPUS" -eq 1 ]; then
			trykernel=kernel-image-$version-sun4cdm
		else
			trykernel=kernel-image-$version-sun4dm-smp
		fi
		;;
	    sparc64)
		if [ "$CPUS" -eq 1 ]; then
			trykernel=kernel-image-$version-sun4u
		else
			trykernel=kernel-image-$version-sun4u-smp
		fi
		;;
	esac
	;;
   powerpc)
      version=2.4.22 #hack, hack!
      MODEL=`/bin/archdetect`
      case "$MODEL" in
          "powerpc/powermac_newworld")
              trykernel=kernel-image-$version-powerpc
              ;;
          # what's below is probably nonsense, porters have to start building 2.4 kernels for d-i!
          # But at least the infrastructure will be there and these are the latest versions in 
          # the archive.
          "powerpc/powermac_oldworld")
              trykernel=kernel-image-$version-powerpc
              ;;
          "powerpc/prep")
              trykernel=kernel-image-2.2.20-prep
              ;;
	  # do we need a special case here for powerpc/chrp_pegasos?
          "powerpc/chrp")
              trykernel=kernel-image-2.2.20-chrp
              ;;
          "powerpc/amiga")
              trykernel=kernel-image-2.4.20-apus
              ;;
          *)
              log "warning: Unknown powerpc subarchitecture '$MODEL'."
              ;;
      esac
      ;;
    mips)
	MODEL=`grep '^system type' /proc/cpuinfo |cut -d: -f2`
	CPU=`grep '^cpu model' /proc/cpuinfo |cut -d: -f2`
	case "$MODEL" in
	    *Indy)
		case "$CPU" in
		    " R4"*)
			trykernel=kernel-image-*-r4k-ip22
			;;
		    " R5"*)
			trykernel=kernel-image-*-r5k-ip22
			;;
		    *)
			log "warning: Unknown mips Indy cpu type '$CPU'."
			;;
		esac
		;;
	    *)
		log "warning: Unknown mips subarchitecture '$MODEL'."
		;;
	esac
	;;
    mipsel)
	MODEL=`grep '^system type' /proc/cpuinfo |cut -d: -f2`
	CPU=`grep '^cpu model' /proc/cpuinfo |cut -d: -f2`
	case "$MODEL" in
	    " DEC"*)
		case "$CPU" in
		    " R3"*)
			trykernel=kernel-image-*-r3k-kn02
			;;
		    " R4"*)
			trykernel=kernel-image-*-r4k-kn04
			;;
		    *)
			log "warning: Unknown mipsel DECstation cpu type '$CPU'."
			;;
		esac
		;;
	    *)
		log "warning: Unknown mipsel subarchitecture '$MODEL'."
		;;
	esac
	;;
    *)
        log "warning: Unknown architecture '$ARCH'."
	;;
esac

if kernel_present $trykernel ; then
    kernel=$trykernel
fi

rm -f $kernel_list

if [ "$kernel" ] ; then
    db_set kernel-installer/which-kernel "$kernel"
fi

db_input medium kernel-installer/which-kernel || [ $? -eq 30 ]
db_go || true

db_get kernel-installer/which-kernel
kernel=$RET

info "Using kernel '$kernel'"

# Pass the kernel name on to kernel-installer
db_set debian-installer/kernel/image "$kernel"

db_progress STEP 1
db_progress INFO kernel-installer/progress/step_config

# =================== Install the kernel =========================

if db_get debian-installer/kernel/linux/initrd ; then
    if [ "$RET" = "true" ]; then
	do_initrd=yes
    else
	do_initrd=no
    fi
else
    warning "Failed to get debconf answer 'debian-installer/kernel/linux/initrd'."
    warning "Setting default do_initrd='yes'."
    do_initrd=yes
fi

if db_get debian-installer/kernel/linux/link_in_boot ; then
    if [ "$RET" = "true" ]; then
	link_in_boot=yes
    else
	link_in_boot=no
    fi
else
    warning "Failed to get debconf answer 'debian-installer/kernel/linux/link_in_boot'."
    warning "Setting default link_in_boot='no'."
    link_in_boot=no
fi

info "Setting do_initrd='$do_initrd'."
info "Setting link_in_boot='$link_in_boot'."

cat > /target/etc/kernel-img.conf <<EOF
# Do not create symbolic links in /
do_symlinks = yes
relative_links = yes
do_bootloader = no
do_bootfloppy = no
do_initrd = $do_initrd
link_in_boot = $link_in_boot
EOF

if [ yes = "$do_initrd" ] ; then
    # Make sure initrd-tools is installed before we change its configuration
    apt-install initrd-tools 2>> $logfile

    # Avoid possible root shell without giving passord while booting
    # the 2.4 kernel
    mkinitrdconf=/target/etc/mkinitrd/mkinitrd.conf
    if [ -f $mkinitrdconf ] ; then
	sed 's/^DELAY=.*/DELAY=0/' < $mkinitrdconf > $mkinitrdconf.new &&
            mv $mkinitrdconf.new  $mkinitrdconf
    else
	echo 'DELAY=0' >> $mkinitrdconf
    fi
fi

if db_get debian-installer/kernel/image ; then
    if [ -z "$RET" ] ; then
	error "Empty value in 'debian-installer/kernel/image'!"
	error "Unable to install kernel."

	db_input critical kernel-installer/no-kernel || [ $? -eq 30 ]
	db_go
	db_progress STOP
	exit 1
    fi
    kernel="$RET"
else
    warning "Unable to get debconf answer debian-installer/kernel/image."
    kernel=kernel-image
    warning "Setting default kernel='$kernel'"
fi

db_progress STEP 1
db_subst kernel-installer/progress/step_install KERNEL "$kernel"
db_progress INFO kernel-installer/progress/step_install

info "Installing kernel '$kernel'."

if ! apt-install "$kernel" 2>> $logfile ; then
    db_subst kernel-installer/failed-install KERNEL "$kernel"
    db_input critical kernel-installer/failed-install || [ $? -eq 30 ]
    db_go
    db_progress STOP
    exit 1
fi

db_progress STEP 1
if [ "$separate_pcmcia_modules" = y ]; then
	pcmcia_package=$(echo "$kernel" | sed 's/^kernel-image/kernel-pcmcia-modules/')
	info "Installing pcmcia package '$pcmcia_package'."
	# TODO uncomment this once string freeze is over and
	# templates file is updated.
	#db_subst kernel-installer/progress/step_install_pcmcia PACKAGE "$pcmcia_package"
	#db_progress INFO kernel-installer/progress/step_install_pcmcia
	if ! apt-install "$pcmcia_package" 2>> $logfile ; then
		:
		# TODO uncomment this once string freeze is over and
		# templates file is updated.
    		#db_subst kernel-installer/failed-pcmcia-install PACKAGE "$pcmcia_package"
		#db_input critical kernel-installer/failed-pcmcia-install || [ $? -eq 30 ]
		#db_go
		#db_progress STOP
		#exit 1
	fi
fi

db_progress STEP 1
db_progress STOP

exit 0
