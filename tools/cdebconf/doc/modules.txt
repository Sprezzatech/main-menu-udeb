XXX -- General things which are missing
XXX Documentation of frontend API
XXX Refactoring to be more readable -- sections will need to be moved.

General APIs
~~~~~~~~~~~~
Tags are strings consisting of identifiers seperated by "::"
XXX How to choose tags?

configuration API
~~~~~~~~~~~~~~~~~

A "struct configuration" has several publically accessible methods:

const char *get(struct configuration *, const char *tag, const char *default):
   Return a string value for given tag

int geti(struct configuration *, const char *tag, int default)
   Return an integral value for given tag

void set(struct configuration *, const char *tag, const char *value):
   Save string value at tag

void seti(struct configuration *, const char *tag, int value)
   Save integral value at tag

XXX memory ownership not discussed
XXX new/delete, read/dump not documented

template API
~~~~~~~~~~~~
Initializing a template should be done via the function
struct template *template_new(const char * tag). This function takes
a tag, and returns an empty template object.

A template has the following publically accessible fields:

- char *tag: the template's tag
- char *type: the template's type XXX can be one of ...
- char *defaultval: the template's default value, as a string
- char *choices: if the template's type is choices based, here the choices
                 are listed in a single string, seperated by commas XXX right?
- char *description: a description of the template XXX must be under ... chars?
- char *extended_description: a longer description 
- struct language_description *localized descriptions - has following fields:
  - struct language_description *next: NULL or another localized description
  - char *language: ISO tag for language XXX right?
  - char *choices, char *description, char *extended_description: as above,
    only in specified language
  
XXX not covering "next", I assume it is private
XXX not covering memory management or deletion

question API
~~~~~~~~~~~~
struct questionvariable has the following fields:
- char *variable: name
- char *value: value
- struct questionvariable *: next variable or NULL

XXX what are variables, and does anything use them?
XXX only references I've seen are in db modules

struct questionowner has the following fields:
- char *owner: the owner
- struct questionowner *next: next owner or NULL

These are documented here because the serializer needs to be able
to write all of them out. In general, nothing should directly modify
those except via the APIs.

struct question has the following public fields:

* char *tag: the tag for this question
* char *value: the value for this question
* char *defaultvalue: the default value for this question
* struct template *template: the template belonging to this question
* unsigned int flags: XXX
* struct questionvariable *variables: list of variables
* struct questionowner *owners: list of owners

XXX not documenting next/prev

The following functions are supported:

- struct question *question_new(const char *tag):
  allocate and initialize a question
- void question_setvalue(struct question *q, const char *value):
  set the value of a question
  (note that setvalue must *always* be called with non-translated choices)
- void question_owner_add(struct question *q, const char *owner):
  add an owner
- void question_owner_delete(struct question *q, const char *owner)
  remove an owner
- const char *question_description(struct question *q):
  return the description from the question template XXX who owns it?
- const char *question_extended_description(struct question *q):
  return the extended description from the question template XXX who owns it?
- const char *question_choices_translated(struct question *q):
  return the list of choices as a comma seperated string, if possible, 
  translated
- const char *question_choices(struct question *q):
  return the list of choices as a comma seperated string
- const char *question_defaultval(struct question *q):
  return the default value (if in choices, *always* non-translated)

XXX not dealing with variables
XXX not dealing with memory management
  
Writing modules
~~~~~~~~~~~~~~~

cdebconf is designed to allow frontend and database modules to be plugged
in as needed. Modules can be built to support different database backends
(e.g. postgres, ldap, etc) and frontends (e.g. ncurses, gtk, etc).


Database modules:

database.h defines the database module interface. Each database module
needs to export a struct named debconf_database_module of type 
struct database_module, defined as:

struct database_module {
	dcd_initialize_t initialize;
	dcd_shutdown_t shutdown;
	dcd_load_t load;
	dcd_save_t save;
	dcd_template_set_t template_set;
	dcd_template_get_t template_get;
	dcd_template_remove_t template_remove;
	dcd_template_lock_t template_lock;
	dcd_template_unlock_t template_unlock;
	dcd_template_iterate_t template_iterate;
	dcd_question_get_t question_get;
	dcd_question_set_t question_set;
	dcd_question_disown_t question_disown;
	dcd_question_disownall_t question_disownall;
	dcd_question_lock_t question_lock;
	dcd_question_unlock_t question_unlock;
	dcd_question_visible_t question_visible;
	dcd_question_iterate_t question_iterate;
};

General
~~~~~~~
In "common.h", two constants are defined: DC_OK and DC_NOTOK.
Every method which returns an int, unless specified otherwise, should
return DC_OK if it succeeds and DC_NOTOK if it fails.

Each of these methods have a signature defined in database.h. All methods
have a sensible default implementation (usually doing nothing) so that 
you only need to override the ones you need.

All methods are passed the database as a first argument. The database,
besides the methods, contains the following attributes:

const char *modname -- the name of the module this database was loaded from XXX
void *handle -- a handle to the shared library. you should probably not use
                this XXX
struct configuration *config -- the configuration of the database. See later
                                about how to use this XXX
void *data -- this is a pointer the database can use to keep it's own private
              data, by allocating some structure and keeping a pointer here
              on initialization, and deleting it on deletion.

Method descriptions:
int initialize(struct database *, struct configuration *): 
    initialize data structures, like cache.
    Get information form the configuration, if you need to.
    XXX WHY? Can't you get the configuration from database->config

int shutdown(struct database *):
    free data structures, like cache

int load(struct database *):
    read in the database structure from a file
    (this is to optimize parsing. if you have no parsing to do, just
    do nothing here)

int save(struct database *): 
    save the database structure back to a file
    This is so not every change will get saved immediately, to optimize
    deserialization. If saving each change immediately is easier, do nothing
    here.

int template_set(struct database *, struct template *):
    save the given template (or, just keep all the information for
    saving later in save())

struct template *template_get(struct database *, char *name):
    return a newly allocated template with the contents of the template whose
    name is "name".
    XXX should return NULL if fails?

int *template_remove(struct database *, char *name):
    remove a template from the database

int *(template|question)_[un]lock(struct database *, char *name):
    XXX WTF? Nothing implements this right now

struct templete *template_iterate(struct database *, void **iter):
    Return "Next template"
    When beginning to iterate, *iter will be NULL.
    On consecutive iterations, it will keep its value.
    It is your reponsibility to free any allocated structure when
    returning NULL, to signify end of iteration.
    Otherwise, return whatever would have been returned by
    calling template_get() with the template's name.

struct question *question_get(struct database *, const char *name):
    Return a newly allocated question object, corresponding to the name.

int question_set(struct database *, struct question *):
    Save the data about the question in the database.

struct question *question_iterate(struct database *, void **iter):
    Return "Next question"
    When beginning to iterate, *iter will be NULL.
    On consecutive iterations, it will keep its value.
    It is your reponsibility to free any allocated structure when
    returning NULL, to signify end of iteration.
    Otherwise, return whatever would have been returned by
    calling question_get() with the question's name.

struct question *question_disown(struct database *, char *name, char *owner):
    Remove the owner from the question.
    XXX - WTF this is done here instead of the caller getting the question, 
    removing the owner and setting the question is a mystery. Perhaps there
    are cases where it will be much less efficient?

struct question *question_disown_all(struct database *, char *owner):
    Remove the owner from all questions.
    Semantically, this should be the same as iterating, and for each question
    removing the owner and resetting it. However, you might be able to avoid
    iterating on some of the question, if the backend is structured correctly.

int question_visible(struct database *, char *name, char *priority)
    XXX - WTF, nothing implements this either.

See modules/db/* for some examples.

Frontend modules

Similarly, frontend modules have an interface defined in frontend.h.
Modules export a struct called debconf_frontend_module of type 
struct frontend_module, defined as:

struct frontend_module {
	dcf_initialize_t initialize;
	dcf_shutdown_t shutdown;
	dcf_query_capability_t query_capability;
	dcf_set_title_t set_title;
	dcf_add_t add;
	dcf_go_t go;
	dcf_clear_t clear;
};

Each of these methods have a signature defined in frontend.h. All methods
have a sensible default implementation (usually doing nothing) so that 
you only need to override the ones you need.

/* TODO: describe each method */

See modules/frontend/* for examples.

$Id: modules.txt,v 1.4 2002/05/28 12:36:57 moshez Exp $
