#!/bin/sh

. /lib/partman/definitions.sh

# If you are curious why partman-auto is so slow, it is because
# update-all is slow
update_all () {
    local dev num id size type fs path name partitions
    for dev in $DEVICES/*; do
	[ -d "$dev" ] || continue
	cd $dev
	partitions=''
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
	    partitions="$partitions $id"
	done
	close_dialog
	for id in $partitions; do
	    update_partition $dev $id
	done
    done
}

autopartitioning_failed () {
    db_fset partman-auto/autopartitioning_failed seen false
    db_input critical partman-auto/autopartitioning_failed || true
    db_go || true
    update_all
    exit 1
}

unnamed=0

decode_recipe () {
    local ram line word min factor max fs -
    unnamed=$(($unnamed + 1))
    ram=$(cat /proc/meminfo | grep ^Mem: | { read x y z; echo $y; }) # in bytes
    ram=$(expr 000000"$ram" : '0*\(.*\)......$') # convert to megabytes
    name="Unnamed.${unnamed}"
    scheme=''
    line=''
    for word in $(cat $1); do
	case $word in
	    :)
		name=$line
		line=''
		;;
	    ::)
		db_metaget $line description
		if [ "$RET" ]; then
		    name=$RET
		else
		    name="Unnamed.${unnamed}"
		fi
		line=''
		;;
	    .)
		# correct errors in order not to crash parted_server
		set -- $line
		if expr "$1" : '[0-9][0-9]*$' >/dev/null; then
		    min=$1
		elif expr "$1" : '[0-9][0-9]*%$' >/dev/null; then
		    min=$(($ram * ${1%?} / 100))
		else
		    min=2200000000
		fi
		if expr "$2" : '[0-9][0-9]*%$' >/dev/null; then
		    factor=$(($ram * ${2%?} / 100))
		elif expr "$2" : '[0-9][0-9]*$' >/dev/null; then
		    factor=$2
		else
		    factor=$min
		fi
		if [ "$factor" -lt "$min" ]; then
		    factor="$min"
		fi
		if expr "$3" : '[0-9][0-9]*$' >/dev/null; then
		    max=$3
		elif expr "$3" : '[0-9][0-9]*%$' >/dev/null; then
		    max=$(($ram * ${3%?} / 100))
		else
		    max=$min
		fi
		if [ "$max" -lt "$min" ]; then
		    max="$min"
		fi
		case "$4" in
		    ext2|ext3|linux-swap|fat16|fat32)
			fs="$4"
			;;
		    *)
			fs=ext2
			;;
		esac
		shift; shift; shift; shift
		line="$min $factor $max $fs $*"
		if [ "$scheme" ]; then
		    scheme="${scheme}${NL}${line}"
		else
		    scheme="$line"
		fi
		line=''
		;;
	    *)
		if [ "$line" ]; then
		    line="$line $word"
		else
		    line="$word"
		fi
	esac
    done
}

foreach_partition () {
    local - doing IFS partition former last
    doing=$1
    IFS="$NL"
    former=''
    for partition in $scheme; do
	restore_ifs
	if [ "$former" ]; then
	    set -- $former
	    last=no
	    eval "$doing"
	fi
	former="$partition"
    done
    if [ "$former" ]; then
	set -- $former
	last=yes
	eval "$doing"
    fi
}

min_size () {
    local size
    size=0
    foreach_partition '
	size=$(($size + $1))'
    echo $size
}

factor_sum () {
    local factor
    factor=0
    foreach_partition '
	factor=$(($factor + $2))'
    echo $factor
}

partition_before () {
    local num id size type fs path name result found
    result=''
    found=no
    open_dialog PARTITIONS
    while { read_line num id size type fs path name; [ "$id" ]; }; do
	if [ "$id" = "$1" ]; then
	    found=yes
	fi
	if [ $found = no ]; then
	    result=$id
	fi
    done
    close_dialog
    echo $result
}

partition_after () {
    local num id size type fs path name result found
    result=''
    found=no
    open_dialog PARTITIONS
    while { read_line num id size type fs path name; [ "$id" ]; }; do
	if [ $found = yes -a -z "$result" ]; then
	    result=$id
	fi
	if [ "$id" = "$1" ]; then
	    found=yes
	fi
    done
    close_dialog
    echo $result
}

pull_primary () {
    primary=''
    secondary=''
    foreach_partition '
        if
            [ -z "$primary" ] \
            && echo $* | grep '\''\$primary{'\'' >/dev/null
        then
            primary="$*"
        else
    	    if [ -z "$secondary" ]; then
    	        secondary="$*"
    	    else
                secondary="${secondary}${NL}$*"
    	    fi
        fi'
}

setup_partition () {
    local id flags file line
    id=$1; shift
    while [ "$1" ]; do
	case "$1" in
	    \$bootable{)
	        while [ "$1" != '}' -a "$1" ]; do
		    shift
		done
		open_dialog GET_FLAGS $id
		flags=$(read_paragraph)
		close_dialog
		open_dialog SET_FLAGS $id
		write_line "$flags"
		write_line boot
		write_line NO_MORE
		close_dialog
		;;
	    \$*{)
                while [ "$1" != '}' -a "$1" ]; do
		    shift
		done
		;;
	    *{)
		file=${1%?}
		[ -d $id ] || mkdir $id
		>$id/$file
		shift
		line=''
	        while [ "$1" != '}' -a "$1" ]; do
		    if [ "$1" = ';' ]; then
			echo "$line" >>$id/$file
		    else
			if [ "$line" ]; then
			    line="$line $1"
			else
			    line="$1"
			fi
		    fi
		    shift
		done
		echo "$line" >>$id/$file
	esac
	shift
    done
    return 0
}

# Let us be safe and update the directories
update_all

dev=$1
free_space=$2

cd $dev
open_dialog PARTITION_INFO $free_space
read_line x1 x2 free_size free_type x3 x4 x5
close_dialog

if [ "$free_type" = unusable ]; then
    db_fset partman-auto/unusable_space seen false
    db_input critical partman-auto/unusable_space || true
    db_go || true
    exit 1
fi

free_size=$(expr 000000"$free_size" : '0*\(.*\)......$') # convert to megabytes

choices=''
for recipe in /lib/partman/recipes/*; do
    [ -f "$recipe" ] || continue
    decode_recipe $recipe
    if [ $(min_size) -le $free_size ]; then
	choices="${choices}${recipe}${TAB}${name}${NL}"
    fi
done

db_metaget partman-auto/text/expert_recipe description
choices="${choices}expert${TAB}${RET}"

db_fset partman-auto/choose_recipe seen false
debconf_select high partman-auto/choose_recipe "$choices" no_default
if [ "$?" = 255 ]; then
    exit 0
fi

case $RET in
    expert)
	db_fset partman-auto/expert_recipe seen false
	db_input critical partman-auto/expert_recipe || true
	if ! db_go; then
	    exit 1
	fi
	decode_recipe $RET
	;;
    *)
	decode_recipe $RET
	;;
esac


# Make factors small numbers so we can multiply on them.
# Also ensure that fact, max and fs are valid
# (Ofcourse in valid recipes they must be valid.)
factsum=$(($(factor_sum) - $(min_size)))
scheme=$(
    foreach_partition '
        local min fact max fs
        min=$1
	fact=$((($2 - $min) * 100 / $factsum))
	max=$3
	fs=$4
        case "$fs" in
	    ext2|ext3|linux-swap|fat16|fat32)
		true
		;;
	    *)
		fs=ext2
		;;
        esac
	shift; shift; shift; shift
	echo $min $fact $max $fs $*'
)

oldscheme=''
while [ "$scheme" != "$oldscheme" ]; do
    oldscheme="$scheme"
    factsum=$(factor_sum)
    unallocated=$(($free_size - $(min_size)))
    if [ $unallocated -lt 0 ]; then
	unallocated=0
    fi
    scheme=$(
	foreach_partition '
	    local min fact max newmin
	    min=$1
	    fact=$2
	    max=$3
	    shift; shift; shift
	    newmin=$(($min + $unallocated * $fact / $factsum))
	    if [ $newmin -le $max ]; then
		echo $newmin $fact $max $*
	    else
		echo $max 0 $max $*
	    fi'
    )
done

while
    [ "$free_type" = pri/log ] \
    && echo $scheme | grep '\$primary{' >/dev/null
do
    pull_primary
    set -- $primary
    open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001
    read_line num id size type fs path name
    close_dialog
    if [ -z "$id" ]; then
	autopartitioning_failed
    fi
    neighbour=$(partition_after $id)
    if [ "$neighbour" ]; then
	open_dialog PARTITION_INFO $neighbour
	read_line x1 new_free_space x2 new_free_type fs x3 x4
	close_dialog
    fi
    if 
	[ -z "$neighbour" -o "$fs" != free -o "$new_free_type" = unusable ]
    then
	open_dialog DELETE_PARTITION $id
	close_dialog
	open_dialog NEW_PARTITION primary $4 $free_space end ${1}000001
	read_line num id size type fs path name
	close_dialog
	if [ -z "$id" ]; then
	    autopartitioning_failed
	fi
	neighbour=$(partition_before $id)
	if [ "$neighbour" ]; then
	    open_dialog PARTITION_INFO $neighbour
	    read_line x1 new_free_space x2 new_free_type fs x3 x4
	    close_dialog
	fi
	if 
	    [ -z "$neighbour" -o "$fs" != free -o "$new_free_type" = unusable ]
	then
	    open_dialog DELETE_PARTITION $id
	    close_dialog
	    autopartitioning_failed
	fi
    fi
    shift; shift; shift; shift
    setup_partition $id $*
    primary=''
    scheme="$secondary"
    free_space=$new_free_space
    free_type="$new_free_type"
done

foreach_partition '
    if [ -z "$free_space" ]; then
	autopartitioning_failed
    fi
    open_dialog PARTITION_INFO $free_space
    read_line x1 free_space x2 free_type fs x3 x4
    close_dialog
    if [ "$fs" != free ]; then
        free_type=unusable
    fi
    case "$free_type" in
	primary|logical)
	    type="$free_type"
	    ;;
	pri/log)
	    type=logical
	    ;;
	unusable)
	    autopartitioning_failed
	    ;;
    esac
    if [ "$last" = yes ]; then
        open_dialog NEW_PARTITION $type $4 $free_space full ${1}000001
    else
        open_dialog NEW_PARTITION $type $4 $free_space beginning ${1}000001
    fi
    read_line num id size type fs path name
    close_dialog
    if [ -z "$id" ]; then
	autopartitioning_failed
    fi
    shift; shift; shift; shift
    setup_partition $id $*
    free_space=$(partition_after $id)'

update_all
