<!-- Start of file partitioning/partitioning.xml -->
<!-- $Id: partitioning.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<appendix id="partitioning">
<title
>Partitioning for Debian</title>


<!-- Start of file partitioning/sizing.xml -->
<!-- $Id: sizing.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


 <sect1 id="partition-sizing">
 <title
>Deciding on Debian Partitions and Sizes</title>
<para
>At a bare minimum, GNU/Linux needs one partition for itself. You can have a single partition containing the entire operating system, applications, and your personal files. Most people feel that a separate swap partition is also a necessity, although it's not strictly true. <quote
>Swap</quote
> is scratch space for an operating system, which allows the system to use disk storage as <quote
>virtual memory</quote
>. By putting swap on a separate partition, Linux can make much more efficient use of it. It is possible to force Linux to use a regular file as swap, but it is not recommended. </para
><para
>Most people choose to give GNU/Linux more than the minimum number of partitions, however. There are two reasons you might want to break up the file system into a number of smaller partitions. The first is for safety. If something happens to corrupt the file system, generally only one partition is affected. Thus, you only have to replace (from the backups you've been carefully keeping) a portion of your system. At a bare minimum, you should consider creating what is commonly called a <quote
>root partition</quote
>. This contains the most essential components of the system. If any other partitions get corrupted, you can still boot into GNU/Linux to fix the system. This can save you the trouble of having to reinstall the system from scratch. </para
><para
>The second reason is generally more important in a business setting, but it really depends on your use of the machine. For example, a mail server getting spammed with e-mail can easily fill a partition. If you made <filename
>/var/mail</filename
> a separate partition on the mail server, most of the system will remain working even if you get spammed. </para
><para
>The only real drawback to using more partitions is that it is often difficult to know in advance what your needs will be. If you make a partition too small then you will either have to reinstall the system or you will be constantly moving things around to make room in the undersized partition. On the other hand, if you make the partition too big, you will be wasting space that could be used elsewhere. Disk space is cheap nowadays, but why throw your money away? </para>
 </sect1>
<!--   End of file partitioning/sizing.xml -->

<!-- Start of file partitioning/tree.xml -->
<!-- $Id: tree.xml 39465 2006-07-30 15:03:12Z fjp $ -->


 <sect1 id="directory-tree">
 <title
>The Directory Tree</title>
<para
>&debian; adheres to the <ulink url="&url-fhs-home;"
>Filesystem Hierarchy Standard</ulink
> for directory and file naming. This standard allows users and software programs to predict the location of files and directories. The root level directory is represented simply by the slash <filename
>/</filename
>. At the root level, all Debian systems include these directories: <informaltable
> <tgroup cols="2">
<thead>
<row>
  <entry
>Directory</entry
><entry
>Content</entry>
</row>
</thead>

<tbody>
<row>
  <entry
><filename
>bin</filename
></entry>
  <entry
>Essential command binaries</entry>
</row
><row>
  <entry
><filename
>boot</filename
></entry>
  <entry
>Static files of the boot loader</entry>
</row
><row>
  <entry
><filename
>dev</filename
></entry>
  <entry
>Device files</entry>
</row
><row>
  <entry
><filename
>etc</filename
></entry>
  <entry
>Host-specific system configuration</entry>
</row
><row>
  <entry
><filename
>home</filename
></entry>
  <entry
>User home directories</entry>
</row
><row>
  <entry
><filename
>lib</filename
></entry>
  <entry
>Essential shared libraries and kernel modules</entry>
</row
><row>
  <entry
><filename
>media</filename
></entry>
  <entry
>Contains mount points for replaceable media</entry>
</row
><row>
  <entry
><filename
>mnt</filename
></entry>
  <entry
>Mount point for mounting a file system temporarily</entry>
</row
><row>
  <entry
><filename
>proc</filename
></entry>
  <entry
>Virtual directory for system information (2.4 and 2.6 kernels)</entry>
</row
><row>
  <entry
><filename
>root</filename
></entry>
  <entry
>Home directory for the root user</entry>
</row
><row>
  <entry
><filename
>sbin</filename
></entry>
  <entry
>Essential system binaries</entry>
</row
><row>
  <entry
><filename
>sys</filename
></entry>
  <entry
>Virtual directory for system information (2.6 kernels)</entry>
</row
><row>
  <entry
><filename
>tmp</filename
></entry>
  <entry
>Temporary files</entry>
</row
><row>
  <entry
><filename
>usr</filename
></entry>
  <entry
>Secondary hierarchy</entry>
</row
><row>
  <entry
><filename
>var</filename
></entry>
  <entry
>Variable data</entry>
</row
><row>
  <entry
><filename
>srv</filename
></entry>
  <entry
>Data for services provided by the system</entry>
</row
><row>
  <entry
><filename
>opt</filename
></entry>
  <entry
>Add-on application software packages</entry>
</row>
</tbody
></tgroup
></informaltable>
</para>

<para
>The following is a list of important considerations regarding directories and partitions. Note that disk usage varies widely given system configuration and specific usage patterns. The recommendations here are general guidelines and provide a starting point for partitioning. </para>
<itemizedlist>
<listitem
><para
>The root partition <filename
>/</filename
> must always physically contain <filename
>/etc</filename
>, <filename
>/bin</filename
>, <filename
>/sbin</filename
>, <filename
>/lib</filename
> and <filename
>/dev</filename
>, otherwise you won't be able to boot. Typically 150&ndash;250MB is needed for the root partition. </para
></listitem>
<listitem
><para
><filename
>/usr</filename
>: contains all user programs (<filename
>/usr/bin</filename
>), libraries (<filename
>/usr/lib</filename
>), documentation (<filename
>/usr/share/doc</filename
>), etc. This is the part of the file system that generally takes up most space. You should provide at least 500MB of disk space. This amount should be increased depending on the number and type of packages you plan to install. A generous workstation or server installation should allow 4&ndash;6GB. </para
></listitem>
<listitem
><para
><filename
>/var</filename
>: variable data like news articles, e-mails, web sites, databases, the packaging system cache, etc. will be placed under this directory. The size of this directory depends greatly on the usage of your system, but for most people will be dictated by the package management tool's overhead. If you are going to do a full installation of just about everything Debian has to offer, all in one session, setting aside 2 or 3 GB of space for <filename
>/var</filename
> should be sufficient. If you are going to install in pieces (that is to say, install services and utilities, followed by text stuff, then X, ...), you can get away with 300&ndash;500 MB. If hard drive space is at a premium and you don't plan on doing major system updates, you can get by with as little as 30 or 40 MB. </para
></listitem>
<listitem
><para
><filename
>/tmp</filename
>: temporary data created by programs will most likely go in this directory. 40&ndash;100MB should usually be enough. Some applications &mdash; including archive manipulators, CD/DVD authoring tools, and multimedia software &mdash; may use <filename
>/tmp</filename
> to temporarily store image files. If you plan to use such applications, you should adjust the space available in <filename
>/tmp</filename
> accordingly. </para
></listitem>
<listitem
><para
><filename
>/home</filename
>: every user will put his personal data into a subdirectory of this directory. Its size depends on how many users will be using the system and what files are to be stored in their directories. Depending on your planned usage you should reserve about 100MB for each user, but adapt this value to your needs. Reserve a lot more space if you plan to save a lot of multimedia files (pictures, MP3, movies) in your home directory. </para
></listitem>
</itemizedlist>

 </sect1>
<!--   End of file partitioning/tree.xml -->

<!-- Start of file partitioning/schemes.xml -->
<!-- $Id: schemes.xml 39465 2006-07-30 15:03:12Z fjp $ -->


 <sect1>
 <title
>Recommended Partitioning Scheme</title>
<para
>For new users, personal Debian boxes, home systems, and other single-user setups, a single <filename
>/</filename
> partition (plus swap) is probably the easiest, simplest way to go. However, if your partition is larger than around 6GB, choose ext3 as your partition type. Ext2 partitions need periodic file system integrity checking, and this can cause delays during booting when the partition is large. </para
><para
>For multi-user systems or systems with lots of disk space, it's best to put <filename
>/usr</filename
>, <filename
>/var</filename
>, <filename
>/tmp</filename
>, and <filename
>/home</filename
> each on their own partitions separate from the <filename
>/</filename
> partition. </para
><para
>You might need a separate <filename
>/usr/local</filename
> partition if you plan to install many programs that are not part of the Debian distribution. If your machine will be a mail server, you might need to make <filename
>/var/mail</filename
> a separate partition. Often, putting <filename
>/tmp</filename
> on its own partition, for instance 20&ndash;50MB, is a good idea. If you are setting up a server with lots of user accounts, it's generally good to have a separate, large <filename
>/home</filename
> partition. In general, the partitioning situation varies from computer to computer depending on its uses. </para
><para
>For very complex systems, you should see the <ulink url="&url-multidisk-howto;"
> Multi Disk HOWTO</ulink
>. This contains in-depth information, mostly of interest to ISPs and people setting up servers. </para
><para
>With respect to the issue of swap partition size, there are many views. One rule of thumb which works well is to use as much swap as you have system memory. It also shouldn't be smaller than 16MB, in most cases. Of course, there are exceptions to these rules. If you are trying to solve 10000 simultaneous equations on a machine with 256MB of memory, you may need a gigabyte (or more) of swap. </para
><para arch="m68k"
>On the other hand, Atari Falcons and Macs feel pain when swapping, so instead of making a large swap partition, get as much RAM as possible. </para
><para
>On 32-bit architectures (i386, m68k, 32-bit SPARC, and PowerPC), the maximum size of a swap partition is 2GB. That should be enough for nearly any installation. However, if your swap requirements are this high, you should probably try to spread the swap across different disks (also called <quote
>spindles</quote
>) and, if possible, different SCSI or IDE channels. The kernel will balance swap usage between multiple swap partitions, giving better performance. </para
><para
>As an example, an older home machine might have 32MB of RAM and a 1.7GB IDE drive on <filename
>/dev/hda</filename
>. There might be a 500MB partition for another operating system on <filename
>/dev/hda1</filename
>, a 32MB swap partition on <filename
>/dev/hda3</filename
> and about 1.2GB on <filename
>/dev/hda2</filename
> as the Linux partition. </para
><para
>For an idea of the space taken by tasks you might be interested in adding after your system installation is complete, check <xref linkend="tasksel-size-list"/>. </para>

 </sect1>
<!--   End of file partitioning/schemes.xml -->

<!-- Start of file partitioning/device-names.xml -->
<!-- $Id: device-names.xml 56142 2008-09-26 10:45:40Z lunar $ -->


 <sect1 id="device-names">
 <title
>Device Names in Linux</title>
<para
>Linux disks and partition names may be different from other operating systems. You need to know the names that Linux uses when you create and mount partitions. Here's the basic naming scheme: </para>
<itemizedlist arch="not-s390">
<listitem
><para
>The first floppy drive is named <filename
>/dev/fd0</filename
>. </para
></listitem>
<listitem
><para
>The second floppy drive is named <filename
>/dev/fd1</filename
>. </para
></listitem>
<listitem
><para
>The first SCSI disk (SCSI ID address-wise) is named <filename
>/dev/sda</filename
>. </para
></listitem>
<listitem
><para
>The second SCSI disk (address-wise) is named <filename
>/dev/sdb</filename
>, and so on. </para
></listitem>
<listitem
><para
>The first SCSI CD-ROM is named <filename
>/dev/scd0</filename
>, also known as <filename
>/dev/sr0</filename
>. </para
></listitem>
<listitem
><para
>The master disk on IDE primary controller is named <filename
>/dev/hda</filename
>. </para
></listitem>
<listitem
><para
>The slave disk on IDE primary controller is named <filename
>/dev/hdb</filename
>. </para
></listitem>
<listitem
><para
>The master and slave disks of the secondary controller can be called <filename
>/dev/hdc</filename
> and <filename
>/dev/hdd</filename
>, respectively. Newer IDE controllers can actually have two channels, effectively acting like two controllers. <phrase arch="m68k"
> The letters may differ from what shows in the mac program pdisk (i.e. what shows up as <filename
>/dev/hdc</filename
> on pdisk may show up as <filename
>/dev/hda</filename
> in Debian). </phrase
> </para
></listitem>

<listitem arch="m68k"
><para
>The first ACSI device is named <filename
>/dev/ada</filename
>, the second is named <filename
>/dev/adb</filename
>. </para
></listitem>
</itemizedlist>

<itemizedlist arch="s390">
<listitem
><para
>The first DASD device is named <filename
>/dev/dasda</filename
>. </para
></listitem>
<listitem
><para
>The second DASD device is named <filename
>/dev/dasdb</filename
>, and so on. </para
></listitem>
</itemizedlist>

<para arch="not-s390"
>The partitions on each disk are represented by appending a decimal number to the disk name: <filename
>sda1</filename
> and <filename
>sda2</filename
> represent the first and second partitions of the first SCSI disk drive in your system. </para
><para arch="not-s390"
>Here is a real-life example. Let's assume you have a system with 2 SCSI disks, one at SCSI address 2 and the other at SCSI address 4. The first disk (at address 2) is then named <filename
>sda</filename
>, and the second <filename
>sdb</filename
>. If the <filename
>sda</filename
> drive has 3 partitions on it, these will be named <filename
>sda1</filename
>, <filename
>sda2</filename
>, and <filename
>sda3</filename
>. The same applies to the <filename
>sdb</filename
> disk and its partitions. </para
><para arch="not-s390"
>Note that if you have two SCSI host bus adapters (i.e., controllers), the order of the drives can get confusing. The best solution in this case is to watch the boot messages, assuming you know the drive models and/or capacities. </para
><para arch="x86"
>Linux represents the primary partitions as the drive name, plus the numbers 1 through 4. For example, the first primary partition on the first IDE drive is <filename
>/dev/hda1</filename
>. The logical partitions are numbered starting at 5, so the first logical partition on that same drive is <filename
>/dev/hda5</filename
>. Remember that the extended partition, that is, the primary partition holding the logical partitions, is not usable by itself. This applies to SCSI disks as well as IDE disks. </para
><para arch="m68k"
>VMEbus systems using the TEAC FC-1 SCSI floppy drive will see it as normal SCSI disk. To make identification of the drive simpler the installation software will create a symbolic link to the appropriate device and name it <filename
>/dev/sfd0</filename
>. </para
><para arch="sparc"
>Sun disk partitions allow for 8 separate partitions (or slices). The third partition is usually (and is preferred to have) the <quote
>Whole Disk</quote
> partition. This partition references all of the sectors of the disk, and is used by the boot loader (either SILO, or Sun's). </para
><para arch="s390"
>The partitions on each disk are represented by appending a decimal number to the disk name: <filename
>dasda1</filename
> and <filename
>dasda2</filename
> represent the first and second partitions of the first DASD device in your system. </para>
 </sect1>
<!--   End of file partitioning/device-names.xml -->

<!-- Start of file partitioning/partition-programs.xml -->
<!-- $Id: partition-programs.xml 42302 2006-10-28 23:28:36Z fjp $ -->

 <sect1 id="partition-programs">
 <title
>Debian Partitioning Programs</title>
<para
>Several varieties of partitioning programs have been adapted by Debian developers to work on various types of hard disks and computer architectures. Following is a list of the program(s) applicable for your architecture. </para>

<variablelist>

<varlistentry>
<term
><command
>partman</command
></term>
<listitem
><para
>Recommended partitioning tool in Debian. This Swiss army knife can also resize partitions, create filesystems <phrase arch="x86"
> (<quote
>format</quote
> in Windows speak)</phrase
> and assign them to the mountpoints. </para
></listitem>
</varlistentry>

<varlistentry condition="fdisk.txt">
<term
><command
>fdisk</command
></term>
<listitem
><para
>The original Linux disk partitioner, good for gurus. </para
><para
>Be careful if you have existing FreeBSD partitions on your machine. The installation kernels include support for these partitions, but the way that <command
>fdisk</command
> represents them (or not) can make the device names differ. See the <ulink url="&url-linux-freebsd;"
>Linux+FreeBSD HOWTO</ulink
>. </para
></listitem>
</varlistentry>

<varlistentry condition="cfdisk.txt">
<term
><command
>cfdisk</command
></term>
<listitem
><para
>A simple-to-use, full-screen disk partitioner for the rest of us. </para
><para
>Note that <command
>cfdisk</command
> doesn't understand FreeBSD partitions at all, and, again, device names may differ as a result. </para
></listitem>
</varlistentry>

<varlistentry condition="atari-fdisk.txt">
<term
><command
>atari-fdisk</command
></term>
<listitem
><para
>Atari-aware version of <command
>fdisk</command
>. </para
></listitem>
</varlistentry>

<varlistentry condition="amiga-fdisk.txt">
<term
><command
>amiga-fdisk</command
></term>
<listitem
><para
>Amiga-aware version of <command
>fdisk</command
>. </para
></listitem>
</varlistentry>

<varlistentry condition="mac-fdisk.txt">
<term
><command
>mac-fdisk</command
></term>
<listitem
><para
>Mac-aware version of <command
>fdisk</command
>. </para
></listitem>
</varlistentry>

<varlistentry condition="pmac-fdisk.txt">
<term
><command
>pmac-fdisk</command
></term>
<listitem
><para
>PowerMac-aware version of <command
>fdisk</command
>, also used by BVM and Motorola VMEbus systems. </para
></listitem>
</varlistentry>

<varlistentry condition="fdasd.txt">
<term
><command
>fdasd</command
></term>
<listitem
><para
>&arch-title; version of <command
>fdisk</command
>; Please read the fdasd manual page or chapter 13 in <ulink url="http://oss.software.ibm.com/developerworks/opensource/linux390/docu/l390dd08.pdf"
> Device Drivers and Installation Commands</ulink
> for details. </para
></listitem>
</varlistentry>
</variablelist>

<para
>One of these programs will be run by default when you select <guimenuitem
>Partition disks</guimenuitem
> (or similar). It may be possible to use a different partitioning tool from the command line on VT2, but this is not recommended. </para
><para arch="x86"
>Remember to mark your boot partition as <quote
>Bootable</quote
>. </para
><para condition="mac-fdisk.txt"
>One key point when partitioning for Mac type disks is that the swap partition is identified by its name; it must be named <quote
>swap</quote
>. All Mac linux partitions are the same partition type, Apple_UNIX_SRV2. Please read the fine manual. We also suggest reading the <ulink url="&url-mac-fdisk-tutorial;"
>mac-fdisk Tutorial</ulink
>, which includes steps you should take if you are sharing your disk with MacOS. </para>


<!-- Start of file partitioning/partition/alpha.xml -->
<!-- $Id: alpha.xml 39920 2006-08-17 17:52:44Z fjp $ -->


  <sect2 arch="alpha"
><title
>Partitioning for &arch-title;</title>
<para
>Booting Debian from the SRM console (the only disk boot method supported by &releasename;) requires you to have a BSD disk label, not a DOS partition table, on your boot disk. (Remember, the SRM boot block is incompatible with MS-DOS partition tables &mdash; see <xref linkend="alpha-firmware"/>.) As a result, <command
>partman</command
> creates BSD disk labels when running on &architecture;, but if your disk has an existing DOS partition table the existing partitions will need to be deleted before <command
>partman</command
> can convert it to use a disk label. </para
><para
>If you have chosen to use <command
>fdisk</command
> to partition your disk, and the disk that you have selected for partitioning does not already contain a BSD disk label, you must use the <quote
>b</quote
> command to enter disk label mode. </para
><para
>Unless you wish to use the disk you are partitioning from Tru64 Unix or one of the free 4.4BSD-Lite derived operating systems (FreeBSD, OpenBSD, or NetBSD), you should <emphasis
>not</emphasis
> create the third partition as a <quote
>whole disk</quote
> partition (i.e. with start and end sectors to span the whole disk), as this renders the disk incompatible with the tools used to make it bootable with aboot. This means that the disk configured by the installer for use as the Debian boot disk will be inaccessible to the operating systems mentioned earlier. </para
><para
>Also, because <command
>aboot</command
> is written to the first few sectors of the disk (currently it occupies about 70 kilobytes, or 150 sectors), you <emphasis
>must</emphasis
> leave enough empty space at the beginning of the disk for it. In the past, it was suggested that you make a small partition at the beginning of the disk, to be left unformatted. For the same reason mentioned above, we now suggest that you do not do this on disks that will only be used by GNU/Linux. When using <command
>partman</command
>, a small partition will still be created for <command
>aboot</command
> for convenience reasons. </para
><para condition="FIXME"
>For ARC installations, you should make a small FAT partition at the beginning of the disk to contain <command
>MILO</command
> and <command
>linload.exe</command
> &mdash; 5 megabytes should be sufficient, see <xref linkend="non-debian-partitioning"/>. Unfortunately, making FAT file systems from the menu is not yet supported, so you'll have to do it manually from the shell using <command
>mkdosfs</command
> before attempting to install the boot loader. </para>
  </sect2>
<!--   End of file partitioning/partition/alpha.xml -->

<!-- Start of file partitioning/partition/hppa.xml -->
<!-- $Id: hppa.xml 35595 2006-03-18 21:15:59Z fjp $ -->


  <sect2 arch="hppa"
><title
>Partitioning for &arch-title;</title>
<para
>PALO, the HPPA boot loader, requires a partition of type <quote
>F0</quote
> somewhere in the first 2GB. This is where the boot loader and an optional kernel and RAMdisk will be stored, so make it big enough for that &mdash; at least 4Mb (I like 8&ndash;16MB). An additional requirement of the firmware is that the Linux kernel must reside within the first 2GB of the disk. This is typically achieved by making the root ext2 partition fit entirely within the first 2GB of the disk. Alternatively you can create a small ext2 partition near the start of the disk and mount that on <filename
>/boot</filename
>, since that is the directory where the Linux kernel(s) will be stored. <filename
>/boot</filename
> needs to be big enough to hold whatever kernels (and backups) you might wish to load; 25&ndash;50MB is generally sufficient. </para>
  </sect2>
<!--   End of file partitioning/partition/hppa.xml -->

<!-- Start of file partitioning/partition/x86.xml -->
<!-- $Id: x86.xml 42250 2006-10-26 15:29:36Z fjp $ -->


  <sect2 arch="x86"
><title
>Partitioning for &arch-title;</title>
<para
>If you have an existing other operating system such as DOS or Windows and you want to preserve that operating system while installing Debian, you may need to resize its partition to free up space for the Debian installation. The installer supports resizing of both FAT and NTFS filesystems; when you get to the installer's partitioning step, select the option <guimenuitem
>Manual</guimenuitem
> and then simply select an existing partition and change its size. </para
><para
>The PC BIOS generally adds additional constraints for disk partitioning. There is a limit to how many <quote
>primary</quote
> and <quote
>logical</quote
> partitions a drive can contain. Additionally, with pre 1994&ndash;98 BIOSes, there are limits to where on the drive the BIOS can boot from. More information can be found in the <ulink url="&url-partition-howto;"
>Linux Partition HOWTO</ulink
> and the <ulink url="&url-phoenix-bios-faq-large-disk;"
>Phoenix BIOS FAQ</ulink
>, but this section will include a brief overview to help you plan most situations. </para
><para
><quote
>Primary</quote
> partitions are the original partitioning scheme for PC disks. However, there can only be four of them. To get past this limitation, <quote
>extended</quote
> and <quote
>logical</quote
> partitions were invented. By setting one of your primary partitions as an extended partition, you can subdivide all the space allocated to that partition into logical partitions. You can create up to 60 logical partitions per extended partition; however, you can only have one extended partition per drive. </para
><para
>Linux limits the partitions per drive to 15 partitions for SCSI disks (3 usable primary partitions, 12 logical partitions), and 63 partitions on an IDE drive (3 usable primary partitions, 60 logical partitions). However the normal &debian; system provides only 20 devices for partitions, so you may not install on partitions higher than 20 unless you first manually create devices for those partitions. </para
><para
>If you have a large IDE disk, and are using neither LBA addressing, nor overlay drivers (sometimes provided by hard disk manufacturers), then the boot partition (the partition containing your kernel image) must be placed within the first 1024 cylinders of your hard drive (usually around 524 megabytes, without BIOS translation). </para
><para
>This restriction doesn't apply if you have a BIOS newer than around 1995&ndash;98 (depending on the manufacturer) that supports the <quote
>Enhanced Disk Drive Support Specification</quote
>. Both Lilo, the Linux loader, and Debian's alternative <command
>mbr</command
> must use the BIOS to read the kernel from the disk into RAM. If the BIOS int 0x13 large disk access extensions are found to be present, they will be utilized. Otherwise, the legacy disk access interface is used as a fall-back, and it cannot be used to address any location on the disk higher than the 1023rd cylinder. Once Linux is booted, no matter what BIOS your computer has, these restrictions no longer apply, since Linux does not use the BIOS for disk access. </para
><para
>If you have a large disk, you might have to use cylinder translation techniques, which you can set from your BIOS setup program, such as LBA (Logical Block Addressing) or CHS translation mode (<quote
>Large</quote
>). More information about issues with large disks can be found in the <ulink url="&url-large-disk-howto;"
>Large Disk HOWTO</ulink
>. If you are using a cylinder translation scheme, and the BIOS does not support the large disk access extensions, then your boot partition has to fit within the <emphasis
>translated</emphasis
> representation of the 1024th cylinder. </para
><para
>The recommended way of accomplishing this is to create a small (25&ndash;50MB should suffice) partition at the beginning of the disk to be used as the boot partition, and then create whatever other partitions you wish to have, in the remaining area. This boot partition <emphasis
>must</emphasis
> be mounted on <filename
>/boot</filename
>, since that is the directory where the Linux kernel(s) will be stored. This configuration will work on any system, regardless of whether LBA or large disk CHS translation is used, and regardless of whether your BIOS supports the large disk access extensions. </para>
  </sect2>
<!--   End of file partitioning/partition/x86.xml -->

<!-- Start of file partitioning/partition/ia64.xml -->
<!-- $Id: ia64.xml 43254 2006-12-09 19:03:58Z fjp $ -->


  <sect2 arch="ia64"
><title
>Partitioning for &arch-title;</title>
<para
>The <command
>partman</command
> disk partitioner is the default partitioning tool for the installer. It manages the set of partitions and their mount points to ensure that the disks and filesystems are properly configured for a successful installation. It actually uses <command
>parted</command
> to do the on-disk partitioning. </para>

   <note>
   <title
>EFI Recognized Formats</title>
<para
>The IA-64 EFI firmware supports two partition table (or disk label) formats, GPT and MS-DOS. MS-DOS, the format typically used on i386 PCs, is no longer recommended for IA-64 systems. Although the installer also provides <command
>cfdisk</command
>, you should only use <ulink url="parted.txt"
> <command
>parted</command
></ulink
> because only it can manage both GPT and MS-DOS tables correctly. </para
></note>

<para
>The automatic partitioning recipes for <command
>partman</command
> allocate an EFI partition as the first partition on the disk. You can also set up the partition under the <guimenuitem
>Guided partitioning</guimenuitem
> from the main menu in a manner similar to setting up a <emphasis
>swap</emphasis
> partition. </para
><para
>The <command
>partman</command
> partitioner will handle most disk layouts. For those rare cases where it is necessary to manually set up a disk, you can use the shell as described above and run the <command
>parted</command
> utility directly using its command line interface. Assuming that you want to erase your whole disk and create a GPT table and some partitions, then something similar to the following command sequence could be used: <informalexample
><screen
>
      mklabel gpt
      mkpartfs primary fat 0 50
      mkpartfs primary linux-swap 51 1000
      mkpartfs primary ext2 1001 3000
      set 1 boot on
      print
      quit
</screen
></informalexample
> This creates a new partition table, and three partitions to be used as an EFI boot partition, swap space, and a root file system. Finally it sets the boot flag on the EFI partition. Partitions are specified in Megabytes, with start and end offsets from the beginning of the disk. So, for example, above we created a 1999MB ext2 file system starting at offset 1001MB from the start of the disk. Note that formatting swap space with <command
>parted</command
> can take a few minutes to complete, as it scans the partition for bad blocks. </para>
  </sect2>

  <sect2 arch="ia64"
><title
>Boot Loader Partition Requirements</title>
<para
>ELILO, the IA-64 boot loader, requires a partition containing a FAT file system with the <userinput
>boot</userinput
> flag set. The partition must be big enough to hold the boot loader and any kernels or RAMdisks you may wish to boot. A minimum size would be about 20MB, but if you expect to run with multiple kernels, then 128MB might be a better size. </para
><para
>The EFI Boot Manager and the EFI Shell fully support the GPT table so the boot partition does not necessarily have to be the first partition or even on the same disk. This is convenient if you should forget to allocate the partition and only find out after you have formatted the other partitions on your disk(s). The <command
>partman</command
> partitioner checks for an EFI partition at the same time it checks for a properly set up <emphasis
>root</emphasis
> partition. This gives you an opportunity to correct the disk layout before the package install begins. The easiest way to correct this omission is to shrink the last partition of the disk to make enough free space for adding an EFI partition. </para
><para
>It is strongly recommended that you allocate the EFI boot partition on the same disk as the <emphasis
>root</emphasis
> filesystem. </para>
  </sect2>

  <sect2 arch="ia64"
><title
>EFI Diagnostic Partitions</title>
<para
>The EFI firmware is significantly more sophisticated than the usual BIOS seen on most x86 PCs. Some system vendors take advantage of the ability of the EFI to access files and run programs from a hard disk filesystem to store diagnostics and EFI based system management utilities on the hard disk. This is a separate FAT format filesystem on the system disk. Consult the system documentation and accessories that come with the system for details. The easiest time to set up a diagnostics partition is at the same time you set up the EFI boot partition. </para>
  </sect2>
<!--   End of file partitioning/partition/ia64.xml -->

<!-- Start of file partitioning/partition/mips.xml -->
<!-- $Id: mips.xml 35613 2006-03-19 04:18:28Z tbm $ -->


  <sect2 arch="mips"
><title
>Partitioning for &arch-title;</title>
<para
>SGI machines require an SGI disk label in order to make the system bootable from hard disk. It can be created in the fdisk expert menu. The thereby created volume header (partition number 9) should be at least 3MB large. If the volume header created is too small, you can simply delete partition number 9 and re-add it with a different size. Note that the volume header must start at sector 0. </para>
  </sect2>
<!--   End of file partitioning/partition/mips.xml -->

<!-- Start of file partitioning/partition/powerpc.xml -->
<!-- $Id: powerpc.xml 48741 2007-07-27 00:59:02Z lunar $ -->


  <sect2 arch="powerpc"
><title
>Partitioning Newer PowerMacs</title>
<para
>If you are installing onto a NewWorld PowerMac you must create a special bootstrap partition to hold the boot loader. The size of this partition must have at least 819200 bytes and its partition type must be <emphasis
>Apple_Bootstrap</emphasis
>. If the bootstrap partition is not created with the <emphasis
>Apple_Bootstrap</emphasis
> type your machine cannot be made bootable from the hard disk. This partition can easily be created by creating a new partition in <command
>partman</command
> and telling it to use it as a <quote
>NewWorld boot partition</quote
>, or in <command
>mac-fdisk</command
> using the <userinput
>b</userinput
> command. </para
><para
>The special partition type Apple_Bootstrap is required to prevent MacOS from mounting and damaging the bootstrap partition, as there are special modifications made to it in order for OpenFirmware to boot it automatically. </para
><para
>Note that the bootstrap partition is only meant to hold 3 very small files: the <command
>yaboot</command
> binary, its configuration <filename
>yaboot.conf</filename
>, and a first stage OpenFirmware loader <command
>ofboot.b</command
>. It need not and must not be mounted on your file system nor have kernels or anything else copied to it. The <command
>ybin</command
> and <command
>mkofboot</command
> utilities are used to manipulate this partition. </para
><para
>In order for OpenFirmware to automatically boot &debian; the bootstrap partition should appear before other boot partitions on the disk, especially MacOS boot partitions. The bootstrap partition should be the first one you create. However, if you add a bootstrap partition later, you can use <command
>mac-fdisk</command
>'s <userinput
>r</userinput
> command to reorder the partition map so the bootstrap partition comes right after the map (which is always partition 1). It's the logical map order, not the physical address order, that counts. </para
><para
>Apple disks normally have several small driver partitions. If you intend to dual boot your machine with MacOSX, you should retain these partitions and a small HFS partition (800k is the minimum size). That is because MacOSX, on every boot, offers to initialize any disks which do not have active MacOS partitions and driver partitions. </para>
  </sect2>
<!--   End of file partitioning/partition/powerpc.xml -->

<!-- Start of file partitioning/partition/sparc.xml -->
<!-- $Id: sparc.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


  <sect2 arch="sparc"
><title
>Partitioning for &arch-title;</title>
<para
>Make sure you create a <quote
>Sun disk label</quote
> on your boot disk. This is the only kind of partition scheme that the OpenBoot PROM understands, and so it's the only scheme from which you can boot. The <keycap
>s</keycap
> key is used in <command
>fdisk</command
> to create Sun disk labels. </para
><para
>Furthermore, on &arch-title; disks, make sure your first partition on your boot disk starts at cylinder 0. While this is required, it also means that the first partition will contain the partition table and the boot block, which are the first two sectors of the disk. You must <emphasis
>not</emphasis
> put swap on the first partition of the boot drive, since swap partitions do not preserve the first few sectors of the partition. You can put Ext2 or UFS partitions there; these will leave the partition table and the boot block alone. </para
><para
>It is also advised that the third partition should be of type <quote
>Whole disk</quote
> (type 5), and contain the entire disk (from the first cylinder to the last). This is simply a convention of Sun disk labels, and helps the <command
>SILO</command
> boot loader keep its bearings. </para>
  </sect2>
<!--   End of file partitioning/partition/sparc.xml -->

 </sect1>
<!--   End of file partitioning/partition-programs.xml -->

</appendix>
<!--   End of file partitioning/partitioning.xml -->
