#!/usr/bin/perl -w
# Generates a mirrors_<type>.h file, reading from Mirrors.masterlist.
# Note that there will be duplicate strings in the generated file.
# I am relying on the c compiler to fix this, which gcc does.
#
# Pass in the type of mirror we are interested in (http or ftp), 
# or use httplist or ftplist to generate a list of country codes for the
# mirror type.
use strict;

my $type = shift || die "please specify mirror type\n";

my $hostarch=$ENV{DEB_HOST_ARCH};
if (! defined $hostarch) {
	$hostarch=`dpkg-architecture -qDEB_HOST_ARCH`;
	chomp $hostarch;
}

# Slurp in the mirror file.
my @data;
my %countries;
my %http_countries;
my %ftp_countries;
my $id=0;
open (IN, "Mirrors.masterlist") or die "Mirrors.masterlist: $!";
while (<IN>) {
	chomp;
	if (m/([^:]*):\s+(.*)/) {
		my $key = lc $1;
		my $value = $2;
		if (lc $key eq 'site') {
			$data[$id]->{site} = $value;
			$id++;
		}
		elsif (lc $key eq 'country') {
			$value =~ s/ .*//;
			$value = uc $value;
			$data[$id]->{$key} = $value;
		}
		else {
			$data[$id]->{$key} = $value;
		}
	}
}
close IN;

# Poor man's mirror rating system: push-primary, push* (-secondary), others
foreach my $id (0..$#data) {
	my $rating=0;
	if (exists $data[$id]->{type}) {
	        $rating=1 if $data[$id]->{type} =~ /push/i;
                $rating=2 if $data[$id]->{type} =~ /push-primary/i;
        }
       $data[$id]->{rating}=$rating;
}

my @newdata;
foreach my $id (0..$#data) {
	if (exists $data[$id]->{'archive-architecture'}) {
		my @arches = split ' ', $data[$id]->{'archive-architecture'};
		if (grep /^!/, @arches) {
			my %notarches = map { substr($_, 1) => 1 } grep /^!/, @arches;
			next if exists $notarches{$hostarch};
		} else {
			my %arches = map { $_ => 1 } @arches;
			next if not exists $arches{$hostarch};
		}
	}
	push @newdata, $data[$id];
}
@data = @newdata;

if ($type =~ /(.*)list/) {
	my $type=$1;
 	open (LIST, ">debian/${type}list-countries") or die "debian/${type}list-countries: $!";
	foreach my $id (0..$#data) {
		next unless exists $data[$id]->{"archive-$type"} and
		                    exists $data[$id]->{country};
		$countries{$data[$id]->{country}} = 1;
	}
	foreach  my $country (sort (keys %countries)) {
		print LIST "${country}\n";
	}
	close LIST;
}
else {
	open (OUT, ">mirrors_$type.h") or die "mirrors_$type.h: $!";
	print OUT "/* Automatically generated; do not edit. */\n";

	# Now output the mirror list. It is ordered with better mirrors
	# near the top.
	print OUT "static struct mirror_t mirrors_$type\[] = {\n";
	my $q='"';
	foreach my $id (sort { $data[$b]->{rating} <=> $data[$a]->{rating} } 0..$#data) {
		next unless exists $data[$id]->{"archive-$type"} and
			    exists $data[$id]->{country};
		print OUT "\t{",
			  join(", ", $q.$data[$id]->{site}.$q, $q.$data[$id]->{country}.$q,
				$q.$data[$id]->{"archive-$type"}.$q),
			  "},\n";
	}
	print OUT "\t{NULL, NULL, NULL}\n";
	print OUT "};\n";

	close OUT;
}
