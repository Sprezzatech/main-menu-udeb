#!/bin/sh
set -e

. /usr/share/debconf/confmodule

db_capb backup

INDENT="  "

localecode="debian-installer/locale"
fallbacklocalecode="debian-installer/fallbacklocale"
languagechooserlocalecode="languagechooser/locale"
languagecode="debian-installer/language"
countrycode="debian-installer/country"
languagechooserlanguage="languagechooser/language-name"
shortlist="countrychooser/country-name-shortlist"
fulllist="countrychooser/country-name"

# This is the iso_3166.tab file location
ISO3166TAB=/usr/share/iso-codes/iso_3166.tab
SUPPORTEDLOCALES=/etc/SUPPORTED-short
SHORTLISTS=/etc/shortlists

for list in $ISO3166TAB ; do 
	if [ -f "$list" ]; then
		countries="$list"
	fi
done

error() {
	logger -t countrychooser "error: $@"
	exit 1
}

log() {
	logger -t countrychooser "info: $@"
}

code2country() {
	COUNTRYCODE="$1"
	line=`grep "$COUNTRYCODE" $countries`

	if [ -n "$line" ]; then
		# Remember that country names may have spaces so the code
		# is different than in country2code.
		printf "$INDENT"
		echo $line | cut -b 4-
	else
		error "Unable to locate info on country '$COUNTRYCODE'"
	fi
}

country2code() {
	COUNTRYNAME=$(echo "$1" | sed "s/^$INDENT//" | sed 's/\\,/,/g')
	line=`grep "$COUNTRYNAME$" $countries`

	if [ -n "$line" ]; then
		set $line
		if [ -n "$1" ]; then
			echo "$1"
		fi
	fi
}

cat_shortlist() {
	(out=""
	IFS='
'
	while read line; do
		if $(echo "$line" | grep -q "^:$1\$"); then
			out=1
		elif $(echo "$line" | grep -q "^:"); then
			out=""
		elif [ "$out" ]; then
			echo "$line"
		fi
	done
	) < $SHORTLISTS
}

loccountry2code() {
	COUNTRYNAME=$(echo "$1" | sed "s/^$INDENT//" | sed 's/\\,/,/g')
	line=`cat_shortlist $2| grep "$COUNTRYNAME\$"`
	if [ -n "$line" ]; then
		set $line
		if [ -n "$1" ]; then
			echo "$1"
		fi
	fi
}

# First grab back the country we got from languagechooser
# (or from elsewhere) and populate the debconf database with
# it so that it becomes the default choice
db_get "$countrycode"
if [ -n "$RET" ]; then
	# Remember which code was first used
	# This is needed at the end of the script
	COUNTRYCODE_LANGUAGECHOOSER="$RET"
	COUNTRY_LANGUAGECHOOSER="$(code2country "$RET")"
	db_set "$fulllist" "${COUNTRY_LANGUAGECHOOSER}"
	db_set "$shortlist" "${COUNTRY_LANGUAGECHOOSER}"
fi


# Then grab back the language we got from languagechooser
db_get "$languagechooserlanguage"
if [ -n "$RET" ]; then
	LANGNAME="$RET"
	# languagemap is a script from languagechooser which
	# returns the language list in LANGUAGELIST and the
	# language alone in LANGUAGE
	if ! . languagemap ; then
		LANGUAGE=C
        else
		# We need to remember these for further use
	        LOCALE_LANGUAGECHOOSER=$LOCALE
		LANGUAGECODE_LANGUAGECHOOSER=$LANGUAGE
	fi
fi

# Then grab back the locale we got from languagechooser
db_get "$localecode"
if [ -n "$RET" ]; then
	DEFAULTLOCALE="$RET"
else
	# Just in case
	DEFAULTLOCALE="C"
fi
# If present, keep track of charset or modifier we got from languagechooser
# This charset or modifier is in the fallback locale
EXTRA_LANGUAGECHOOSER=`echo $FALLBACKLOCALE | sed -e 's/^[^.@]*//'`

FIRST_LANG=$(echo $LANGUAGELIST | sed -e 's/:.*$//')

if grep -q "^:$FIRST_LANG\$" $SHORTLISTS; then
  use_lang=$FIRST_LANG
elif grep -q "^:$LANGUAGE\$" $SHORTLISTS; then
  use_lang=$LANGUAGE
else
  use_lang=""
fi

# At this step we should have either xx, or xx_YY in LANGNAME
if [ "$LANGUAGE" != "C" ]; then
	STATE=1
	LASTSTATE=3
	fullprio=high
	shortprio=high
	while [ "$STATE" != 0 -a "$STATE" -le "$LASTSTATE" ]; do
		case "$STATE" in
		1)
			# If the locale includes a country, then
			# don't display the short list, and only show the
			# full list at medium priority.
			if (echo $DEFAULTLOCALE | grep "_" >/dev/null 2>&1) ; then
				askedshort=0
				fullprio=medium
			else
				if [ "$use_lang" ]; then
					# Build a short list of supported locales for
					# the language.
					OLD_IFS="$IFS"
					IFS='
'
					COUNTRIES=$(cat_shortlist $use_lang | sed -e 's/^.*	//');
					SHORTLIST=""
					for name in $COUNTRIES; do
						if [ ! -z "${SHORTLIST}" ]; then
							SHORTLIST="${SHORTLIST}, "
						fi
						countryname=$(echo "${INDENT}${name}" | sed -e 's/,/\\,/')
						SHORTLIST="${SHORTLIST}${countryname}"
					done
					IFS="$OLD_IFS"	
					db_subst $shortlist SHORTLIST "${SHORTLIST}"
					db_subst $shortlist DEFAULTLOCALE "${DEFAULTLOCALE}"
					db_input $shortprio $shortlist || [ $? -eq 30 ]
					askedshort=1
				else
					askedshort=0
				fi
			fi
		;;
		2)
			db_get $shortlist
			if [ "$askedshort" = 1 ] && [ "$RET" != "other" ]; then
     				COUNTRYCODE="$(loccountry2code "$RET" $use_lang )" || true
				if [ -n "$COUNTRYCODE" ]; then
					break
				fi
			fi
			
			db_subst $fulllist DEFAULTLOCALE "${DEFAULTLOCALE}"
			db_input $fullprio $fulllist || [ $? -eq 30 ]
		;;
		3)
			db_get $fulllist
			COUNTRYCODE="$(country2code "$RET")" || true
			if [ -n "$COUNTRYCODE" ]; then
				break
			else
				# User probably selected a region.
				STATE=2
				continue
			fi
		;;
		esac

		if db_go; then
			STATE=$(($STATE + 1))
		else
			STATE=$(($STATE - 1))
		fi
	done

	if [ "$STATE" = 0 ]; then
		exit 10 # back out to main menu
	fi
fi

db_set "$countrycode"  "$COUNTRYCODE"
log "$countrycode = '$COUNTRYCODE'"

# Search for a supported locale which most closely resembles.
LOCALE=""
log "LANGUAGE = '$LANGUAGE'"
log "LANGUAGECODE_LANGUAGECHOOSER = '$LANGUAGECODE_LANGUAGECHOOSER'"
log "COUNTRYCODE = '$COUNTRYCODE'"
log "COUNTRYCODE_LANGUAGECHOOSER = '$COUNTRYCODE_LANGUAGECHOOSER'"
log "LOCALE_LANGUAGECHOOSER = '$LOCALE_LANGUAGECHOOSER'"

for entry in ${LANGUAGE}_${COUNTRYCODE}${EXTRA_LANGUAGECHOOSER} \
	     ${LANGUAGE}_${COUNTRYCODE}; do
	# Is the locale we inherited from languagechooser
	# really a complete locale?
        LOCALE_LANGUAGECHOOSER_COMPLETE=$(echo ${LOCALE_LANGUAGECHOOSER} | grep "_" || true)
	if grep -q "^${entry}$" $SUPPORTEDLOCALES; then
		# Special handling of cases where the locale
		# in languagechooser is NOT the combination of
		# language_COUNTRY. Used for Norwegian Bokmal transition
		# in order to keep no_NO as locale. May be used in the
		# future for other special cases, so we'd better keep this
	        if \
		    [ "${LANGUAGE}" = "${LANGUAGECODE_LANGUAGECHOOSER}" \
		      -a \
		      "${COUNTRYCODE}" = "${COUNTRYCODE_LANGUAGECHOOSER}" \
		      -a \
		      "${LANGUAGE}_${COUNTRYCODE}" != "${LOCALE_LANGUAGECHOOSER}" \
		      -a \
		      -n ${LOCALE_LANGUAGECHOOSER_COMPLETE} \
		    ] ;  then
		    # In details : we revert back to the locale
		    # defined in languagechooser if countrychooser
		    # did NOT induce change in language and country
		    # but the resulting locale is different from the
		    # one we had in languagechooser
		    LOCALE=${LOCALE_LANGUAGECHOOSER}
		else
		    LOCALE="${entry}"
		fi
		break
	fi
done

# Fall back to a supported locale.
if [ -z "${LOCALE}" ]; then
	LOCALE="${FALLBACKLOCALE}"
	log "falling back to locale '${FALLBACKLOCALE}'"
fi

# Set the locale.
db_set "$localecode" "${LOCALE}"
log "$localecode = '${LOCALE}'"

# The code below tries to add lang_COUNTRY at the beginning of the language
# list we got from languagechooser
# Example:
#   -user chooses "Arabic" at languagechooser-->she gets "ar_EG:ar:en_US:en"
#    (see the languagelist file from languagechooser)
#   -she chooses "Syria" as country-->then we end up with 
#    "ar_SY:ar_EG:ar:en_UC:en"
# We shouldn't just add this before the former list in case the country 
# is changed several times.
if [ "$COUNTRYCODE" != "$COUNTRYCODE_LANGUAGECHOOSER" -a -n "$COUNTRYCODE" -a -n $LANGUAGE ]; then
	LANGUAGELIST=${LANGUAGE}_${COUNTRYCODE}:${LANGUAGELIST}
	# Languagelist setting
	db_set "$languagecode" "$LANGUAGELIST"
	log "$languagecode = '$LANGUAGELIST'"
fi

exit 0
