#!/bin/sh

set -e

. /usr/share/debconf/confmodule

findfs () {
	mount | grep "on /target${1%/} " | cut -d' ' -f1
}

rootfs_devfs=$(findfs /)
bootfs_devfs=$(findfs /boot)

# partconf workaround (mounts /target as /target/)
if [ "$rootfs_devfs" = "" ]; then
	rootfs_devfs=$(findfs //)
fi

if [ "$bootfs_devfs" = "" ]; then
	bootfs_devfs=$rootfs_devfs
	boot="boot/"
else
	boot=""
fi

rootfs=$(mapdevfs $rootfs_devfs)
bootfs=$(mapdevfs $bootfs_devfs)

case "`archdetect`" in
	powerpc/chrp_pegasos)
		kernel=`ls /target/boot/vmlinuz-2.* | sed -e 's%/target/boot/%%'`

		kind=`echo $bootfs_devfs | sed -e 's%/dev/%%' -e 's%/host.*$%%'`
		host=`echo $bootfs_devfs | sed -e 's%^.*host%%' -e 's%/bus.*$%%'`
		bus=`echo $bootfs_devfs | sed -e 's%^.*bus%%' -e 's%/target.*$%%'`
		target=`echo $bootfs_devfs | sed -e 's%^.*target%%' -e 's%/lun.*$%%'`
		lun=`echo $bootfs_devfs | sed -e 's%^.*lun%%' -e 's%/part.*$%%'`
		part=$((`echo $bootfs_devfs | sed -e 's%^.*part%%'`-1))

		# We don't know how to map non ide or scsi disks
		# and we have trouble when there is more than one such controller.
		case "$kind","$host" in
			ide,0) path="/pci/ide/disk@$bus,$target"
				;;
			scsi,0) path="/pci/scsi/disk@$bus,$target,$lun"
				;;
			*) path="<unknown path>"
				;;
		esac

		# map theidevice to the OF aliases from /proc/device-tree/aliases.
		if [ -d /proc/device-tree/aliases ]; then
			for alias in `ls /proc/device-tree/aliases/*`; do
				device=`grep disk $alias | sed -e 's%@[^/]*/%/%g'`
				if [ "$path" = "$device" ]; then
					path="${alias#/proc/device-tree/aliases/}"
				fi
			done
		fi

		bootcmd="boot ${path}:${part} ${boot}${kernel} root=${rootfs}"

		db_subst nobootloader/confirmation_powerpc_chrp_pegasos KERNEL_BOOT "${bootcmd}"
		db_subst nobootloader/confirmation_powerpc_chrp_pegasos OF_BOOT_DEVICE "${path}:${part}" 
		db_subst nobootloader/confirmation_powerpc_chrp_pegasos OF_BOOT_FILE "${boot}${kernel} root=${rootfs}"
		db_input high nobootloader/confirmation_powerpc_chrp_pegasos || true
	;;
	arm/netwinder)
		kernel=/vmlinuz
		db_subst nobootloader/confirmation_arm_netwinder_nettrom KERNDEV "$bootfs"
		db_subst nobootloader/confirmation_arm_netwinder_nettrom KERNFILE "$kernel"
		db_subst nobootloader/confirmation_arm_netwinder_nettrom ROOTDEV "$rootfs"
		# TODO: handle serial console
		db_subst nobootloader/confirmation_arm_netwinder_nettrom CMDAPPEND "root=$rootfs"
		db_input high nobootloader/confirmation_arm_netwinder_nettrom || true
	;;
	*)
		db_get base-installer/kernel/linux/link_in_boot
		link_in_boot="$RET"
		if [ "$link_in_boot" = "true" ]; then
			boot_link="boot/"
		else
			boot_link=""
			boot=""
			bootfs=${rootfs}
		fi
		if [ -e /target/${boot_link}vmlinuz ]; then
			kernel="/${boot}vmlinuz"
		elif [ -e /target/${boot_link}vmlinux ]; then
			kernel="/${boot}vmlinux"
		fi

		db_subst nobootloader/confirmation_common ROOT "root=${rootfs}"
		db_subst nobootloader/confirmation_common BOOT "${bootfs}"
		db_subst nobootloader/confirmation_common KERNEL "${kernel}"
		db_input high nobootloader/confirmation_common || true
	;;
esac

db_go || true
