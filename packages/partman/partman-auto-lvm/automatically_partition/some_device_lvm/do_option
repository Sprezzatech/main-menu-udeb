#!/bin/sh

. /lib/partman/definitions.sh
. /lib/partman/recipes.sh
. /lib/partman/lvm_tools.sh
. /lib/partman/auto-shared.sh

dev=$1

[ -f $dev/size ] || exit 1
free_size=$(cat $dev/size)
free_size=$(expr 0000000"$free_size" : '0*\(..*\)......$') # convert to megabytes

# we need to be sure we can perform the selected receipe and be able to add /boot.
# virtually remove 200Mb from the free space. Perhaps a reiteration over the recipe
# would be more accurate, but for now this is more than fine.
free_size=$(expr $free_size - 200)

choose_recipe "$free_size" || exit $?

wipe_disk || exit $?

free_size=$(expr 0000000"$free_size" : '0*\(..*\)......$') # convert to megabytes

decode_recipe $recipe

# check if the recipe contains lvmok tags otherwise fail
if [ -z "$(echo "$scheme" | grep "lvmok")" ]; then
	db_input critical partman-auto-lvm/unusable_recipe || true
	db_go || true
	exit 1
fi

### situation:
### we have a recipe foo from arch bar. we don't know anything other than what
### partitions can go on lvm ($lvmok{ } tag).
### as output we need to have 2 recipes:
### - recipe 1 (normalscheme) that will contain all non-lvm partitions + /boot.
###            We do assume that special /boot requirements are coded in arch specific recipes.
### - recipe 2 everything that can go on lvm and it's calculated in perform_recipe_by_lvm.

# get the scheme of partitions that must be created outside LVM
normalscheme=$(echo "$scheme" | grep -v "lvmok")

# if the schema does NOT contain a /boot, create one.
if ! echo $normalscheme | grep -eq "[[:space:]]/boot[[:space:]]"; then
  bootscheme="${NL}128 512 256 ext3 \$primary{ } \$bootable{ } method{ format } format{ } use_filesystem{ } filesystem{ ext3 } mountpoint{ /boot }" 
fi

# creating envelope
scheme="$normalscheme$bootscheme${NL}100 1000 1000000000 ext3 method{ lvm }"

expand_scheme

clean_method

create_primary_partitions

# this variable will be used to store the partitions that will be LVM
# by create_partitions. zero it to be sure it's not cluttered.
# it will be used later to provide real paths to partitions to LVM.
# (still one atm)
devfspv_devices=''

create_partitions

# write the partition tables
disable_swap
cd $dev
open_dialog COMMIT
close_dialog

update_all

#### now we have the container! yeppa!!! ####

# be sure the modules are loaded
modprobe dm-mod >/dev/null 2>&1 || true
modprobe lvm-mod >/dev/null 2>&1 || true

if type update-dev >/dev/null 2>&1; then
    log-output -t update-dev update-dev
fi

# lvm doesn't like devfs paths.
for pv in $devfspv_devices; do
    realpath="$(mapdevfs "$pv")"
    pv_devices="$pv_devices $realpath"
done

# Choose name, create VG and attach each partition as a physical volume
noninteractive=true
while true; do
    db_input medium partman-auto-lvm/new_vg_name || eval $noninteractive
    db_go || exit 1
    db_get partman-auto-lvm/new_vg_name
    VG_name="$RET"

    if VG_create "$VG_name" $pv_devices; then break; fi
    noninteractive="exit 1"
done

perform_recipe_by_lvm $VG_name $recipe

# default to accepting the autopartitioning
menudir_default_choice /lib/partman/choose_partition finish finish || true
