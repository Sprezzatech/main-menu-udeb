#!/bin/sh

. /lib/partman/definitions.sh
. /lib/partman/recipes.sh
. /lib/partman/lvm_tools.sh
. /lib/partman/auto-shared.sh

bail_out() {
	db_input critical partman-auto-lvm/$1 || true
	db_go || true
	exit 1
}


dev=$1

[ -f $dev/size ] || exit 1
free_size=$(cat $dev/size)
free_size=$(expr 0000000"$free_size" : '0*\(..*\)......$') # convert to megabytes

# be sure the modules are loaded
modprobe dm-mod >/dev/null 2>&1 || true
modprobe lvm-mod >/dev/null 2>&1 || true

if type update-dev >/dev/null 2>&1; then
	log-output -t update-dev update-dev
fi

# check if the device already contains any physical volumes
realdev=$(mapdevfs "$(cat $dev/device)")
if PV_list | grep -q "$realdev" ; then
	bail_out pv_on_device
fi

choose_recipe "$free_size" lvm || exit $?

wipe_disk || exit $?

# Check if partition is usable; use existing partman-auto template as we depend on it
if [ "$free_type" = unusable ]; then
	db_input critical partman-auto/unusable_space || true
	db_go || true
	exit 1
fi
free_size=$(expr 0000000"$free_size" : '0*\(..*\)......$') # convert to megabytes

decode_recipe $recipe lvm

# check if the recipe contains lvmok tags otherwise fail
if [ -z "$(echo "$scheme" | grep "lvmok")" ]; then
	bail_out unusable_recipe
fi

### situation:
### we have a recipe foo from arch bar. we don't know anything other than what
### partitions can go on lvm ($lvmok{ } tag).
### as output we need to have 2 recipes:
### - recipe 1 (normalscheme) that will contain all non-lvm partitions including /boot.
###            The /boot partition should already be defined in the schema.
### - recipe 2 everything that can go on lvm and it's calculated in perform_recipe_by_lvm.

# get the scheme of partitions that must be created outside LVM
normalscheme=$(echo "$scheme" | grep -v "lvmok")

# check if the scheme contains a boot partition; if not warn the user.
if ! echo "$normalscheme" | grep -q "[[:space:]]/boot[[:space:]]"; then
	db_input critical partman-auto-lvm/no_boot || true
	db_go || exit 30
	db_get partman-auto-lvm/no_boot || true
	[ "$RET" = true ] || exit 30
fi

# creating envelope
scheme="$normalscheme${NL}100 1000 1000000000 ext3 method{ lvm }"

expand_scheme

clean_method

create_primary_partitions

# this variable will be used to store the partitions that will be LVM
# by create_partitions. zero it to be sure it's not cluttered.
# it will be used later to provide real paths to partitions to LVM.
# (still one atm)
devfspv_devices=''

create_partitions

# write the partition tables
disable_swap
cd $dev
open_dialog COMMIT
close_dialog

update_all

#### now we have the container! yeppa!!! ####

# lvm doesn't like devfs paths.
for pv in $devfspv_devices; do
	realpath="$(mapdevfs "$pv")"
	pv_devices="$pv_devices $realpath"
done

# Choose name, create VG and attach each partition as a physical volume
noninteractive=true
while true; do
	db_input medium partman-auto-lvm/new_vg_name || eval $noninteractive
	db_go || exit 1
	db_get partman-auto-lvm/new_vg_name
	VG_name="$RET"

	# check if the volume group name is not in use
	if [ -z "$(VG_list | grep " $VG_name${TAB}")" ]; then
		break
	fi
	noninteractive="bail_out vg_exists"
	db_register partman-auto-lvm/new_vg_name_exists partman-auto-lvm/new_vg_name
done

if VG_create "$VG_name" $pv_devices; then
	perform_recipe_by_lvm $VG_name $recipe
else
	bail_out vg_create_error
fi

# default to accepting the autopartitioning
menudir_default_choice /lib/partman/choose_partition finish finish || true
