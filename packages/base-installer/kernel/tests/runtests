#! /bin/sh
set -e

if [ -z "$1" ]; then
	echo "Usage: runtest <architecture>" >&2
	exit 1
fi

ARCH="$1"
PASSES=0
FAILURES=0

[ "$TEST_VERBOSE" ] || export TEST_VERBOSE=1

verbose () {
	if [ "$TEST_VERBOSE" -ge 2 ]; then
		echo "$@"
	fi
	eval "$@"
}

# Run a test based on a test file.
run_test () {
	TEST="$1"

	unset SUBARCH CPUINFO FLAVOUR KERNEL_24 KERNEL_26 USABLE UNUSABLE \
		|| true
	PROCESSORS=1
	MAJORS=2.4

	while read name value; do
		case $name in
			subarch)
				SUBARCH="$value"
				;;
			cpuinfo)
				CPUINFO="${TEST%/*}/$value"
				;;
			processors)
				PROCESSORS="$value"
				;;
			machine)
				MACHINE="$value"
				;;
			majors)
				MAJORS="$value"
				;;
			flavour)
				FLAVOUR="$value"
				;;
			kernel-2.4)
				KERNEL_24="$value"
				;;
			kernel-2.6)
				KERNEL_26="$value"
				;;
			usable)
				USABLE="$value"
				;;
			unusable)
				UNUSABLE="$value"
				;;
			env)
				# TODO: is there any quote-safe way to do
				# this?
				eval "export ${value%% *}='${value#* }'"
				;;
		esac
	done < "$TEST"

	export ARCH SUBARCH CPUINFO PROCESSORS MACHINE
	export MAJORS FLAVOUR KERNEL_24 KERNEL_26
	export USABLE UNUSABLE

	TMP="$(mktemp -t base-installer-tests.XXXXXX)"
	trap 'rm -f "$TMP"' 0 HUP INT QUIT TERM

	# Run the actual testset.
	verbose ./dotest >"$TMP"

	# Massage testset output into a more useful form.
	while read state message; do
		case "$state" in
			PASS)
				PASSES="$(($PASSES + 1))"
				;;
			FAIL)
				FAILURES="$(($FAILURES + 1))"
				;;
		esac
		if [ "$state" != PASS ] || [ "$TEST_VERBOSE" -ge 2 ]; then
			echo "$state $TEST $message"
		fi
	done <"$TMP"
	rm -f "$TMP"
	trap 0 HUP INT QUIT TERM
}

if [ "$2" ]; then
	ONETEST="$2"
	run_test "$ONETEST"
else
	for test in "$ARCH"/*.test; do
		run_test "$test"
	done
fi

if [ "$TEST_VERBOSE" -ge 1 ]; then
	echo "$ARCH: $PASSES passes, $FAILURES failures."
fi

if [ "$FAILURES" -eq 0 ]; then
	exit 0
else
	exit 1
fi
