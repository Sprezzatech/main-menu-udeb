#!/bin/sh
set -e

. /usr/share/debconf/confmodule

db_capb backup

localecode="debian-installer/locale"
langlist="languagechooser/languagelist"
fallbacklocalecode="debian-installer/fallbacklocale"
languagecode="debian-installer/language"
countrycode="debian-installer/country"
consoledisplay="debian-installer/consoledisplay"
shortlist="countrychooser/shortlist"
continentlist="countrychooser/continentlist"
countrylist="countrychooser/countrylist"
supportedlocales="localechooser/supported-locales"

# This is the iso_3166.tab file location
ISO3166TAB=/usr/share/iso-codes/iso_3166.tab
SUPPORTEDLOCALES=/etc/SUPPORTED-short
SHORTLISTS=/etc/shortlists
LANGUAGELISTFILE=/usr/share/localechooser/languagelist
LANGUAGELISTDATA=/usr/share/localechooser/languagelist.data.gz

NL="
"

error() {
	logger -t localechooser "error: $@"
	exit 1
}

log() {
	logger -t localechooser "info: $@"
}


locale2countrycode() {
	if [ -n "$1" ]; then
		if echo $1 | grep -q "_"; then
			echo $1 | cut -f2 -d_ | cut -f1 -d@ | cut -f1 -d\.
		else
			echo
		fi
	else
		error "Missing argument"
	fi
}

choices_add() {
	echo "${1:+$1, }$2"
}

# Determine the display level
language_display_level() {
	local level

	#log "Frontend in use: $DEBIAN_FRONTEND"
	case $DEBIAN_FRONTEND in
	    text)
		level=0 ;;
	    gtk)
		level=4 ;;
	    *)
		# Keep only Latin1 languages if we don't have a framebuffer
		if [ "$TERM_FRAMEBUFFER" ]; then
			level=3
		else
			level=1
		fi
		# ASCII only if we are on serial console or a dumb terminal
		# Both variables should already be set at init time
		if [ "$TERM_TYPE" = "serial" ] || [ "$TERM" = "dumb" ]; then
			level=0
		fi
		;;
	esac

	#log "Language display level is $level"
	echo $level
}

# Build list of available languages for a display level
build_language_template() {
	local level=$1
	local oldlevel=$(cat /var/lib/localechooser/langlevel \
		2>/dev/null || true)
	if [ "$level" = "$oldlevel" ]; then
		return 0
	fi

	local OLDIFS IFS line name codes names_en names_both
	rm -f /var/lib/localechooser/langlevel

	OLDIFS="$IFS"
	IFS="$NL"
	for line in $(zcat $LANGUAGELISTDATA | grep "^[0-$level]:"); do
		name="$(echo "$line" | cut -d: -f3)"
		codes="$(choices_add "$codes" \
			"$(echo "$line" | cut -d: -f2)")"
		names_en="$(choices_add "$names_en" \
			"$name")"
		names_both="$(choices_add "$names_both" \
			"$name\${!TAB}-\${!TAB}$(echo "$line" | cut -d: -f4)")"
	done
	IFS="$OLDIFS"

	db_subst $langlist CODES "$codes"
	db_subst $langlist NAMES_EN "$names_en"
	db_subst $langlist NAMES_BOTH "$names_both"

	echo $level >/var/lib/localechooser/langlevel
}


do_preseed() {
	LOCALE="$1"
	log "Locale has been preseeded to $LOCALE"

	# Only mark variables seen if this one was preseeded seen.
	db_fget $localecode seen
	seenflag=$RET
	db_fset $localecode seen "false" || true

	# Only populate debconf if this is a supported locale
	# and if the language is supported in D-I
	LANGUAGE=${LOCALE%%.*}
	LANGUAGE=${LANGUAGE%%_*}
	if [ -n "$LANGUAGE" ]; then
		db_set $langlist $LANGUAGE
		log "Set $langlist = '$LANGUAGE'"
		db_fset $langlist seen $seenflag || true
		COUNTRY=$(locale2countrycode "$LOCALE")
		if [ -n "$COUNTRY" ]; then
			db_set $countrycode "$COUNTRY"
			log "Set $countrycode = '$COUNTRY'"
			db_fset $countrycode seen $seenflag || true
			db_fset $continentlist seen $seenflag || true
			country_preseeded=1

			if grep -q "^$LOCALE$" $SUPPORTEDLOCALES ; then
				db_set $localecode $LOCALE
				db_fset $localecode seen $seenflag || true
				log "Set $localecode = '$LOCALE'"
			else
				# The locale was invalid, empty it
				LOCALE=""
			fi
		else
			# The locale was invalid, empty it
			LOCALE=""
		fi
	fi
}

# Install specific packages depending on selected language
# Those we install here are those required immediately
# Otherwise we will install them in finish-install
install_lang_specific() {
	if [ "$LOCALE" != "C" ]; then
		case "$LANGUAGE" in
		    ar|el|fa|he|ja|ko|ku|tr|vi|wo|zh*)
			# We need a complete font for later steps
			anna-install bterm-unifont
			;;
		esac
	fi
}

# Change language and switch font for graphical installer
set_debconf_language() {
	db_set "debconf/language" "$1"

	if type gtk-set-font >/dev/null 2>&1; then
		gtk-set-font || true
	fi
}

# Determine which template to display to warn for incomplete translations
# and fill in the variable contents
warning_template() {
	local RET status template tbase twarn tabort
	status=$1
	tbase=localechooser/translation

	case $status in
	    0)	twarn=incomplete; tabort=abort ;;
	    1)	twarn=normal-ok; tabort=abort ;;
	    2)	twarn=partial; tabort=maybe-abort ;;
	    3)	twarn=mostly-ok ;;
	    4)	twarn=exceptions ;;
	esac
	if [ $status -le 2 ]; then
		template=$tbase/warn-severe
		db_metaget $tbase/text/$tabort description
		db_subst $template TXT-ABORT "$RET"
	else
		template=$tbase/warn-light
	fi

	# Languages that have fallbacks may have special templates
	if [ "$twarn" != exceptions ] && \
	   expr $LANGUAGELIST : ".*:" >/dev/null && \
	   db_metaget $tbase/text/warn_$twarn/$LANGUAGE description; then
		:
	else
		db_metaget $tbase/text/warn_$twarn description
	fi
	db_subst $template TXT-WARN "$RET"

	echo $template
}

# Returns 0 if the template has the country among its choices
has_country() {
	local RET template country
	template="$1"
	country="$2"

	[ "$country" ] || return 1

	db_metaget $template Choices-C
	echo "$RET" | grep -q "$country"
}

# Set defaults for continent based on country
set_default_continent() {
	local OLDIFS IFS RET country continents c continent
	country="$1"

	if [ -z "$country" ]; then
		db_reset $continentlist
		return
	fi

	# Use Choices-en.UTF-8 to avoid getting translated values
	db_metaget $continentlist Choices-en.UTF-8
	continents=$(echo $RET | sed "s/, /,/g")

	OLDIFS="$IFS"
	IFS=,
	for continent in $continents; do
		IFS="$OLDIFS"
		c=$(echo "$continent" | sed "s/ /_/g")
		if has_country $countrylist/$c "$country"; then
			db_set $continentlist "$continent"
			break
		fi
	done
}

refine_locale() {
	local old_locale entry
	old_locale=$1

	for entry in ${LANGUAGE}_${COUNTRYCODE}${EXTRA_LANGUAGECHOOSER} \
	             ${LANGUAGE}_${COUNTRYCODE}; do
		# Is the locale we inherited really a complete locale?
		LOCALE_LANGUAGECHOOSER_COMPLETE=$(echo $old_locale | grep "_" || true)
		if grep -q "^$entry$" $SUPPORTEDLOCALES; then
			# Special handling of cases where the locale
			# in languagechooser is NOT the combination of
			# language_COUNTRY. Used for Norwegian
			# Bokmal transition in order to keep no_NO as
			# locale. May be used in the future for other
			# special cases, so we'd better keep this.
			if [ "$LANGUAGE" = "$LANGUAGECODE_LANGUAGECHOOSER" ] && \
			   [ "$COUNTRYCODE" = "$DEFAULT_COUNTRY" ] && \
			   [ "${LANGUAGE}_${COUNTRYCODE}" != "$old_locale" ] && \
			   [ "$LOCALE_LANGUAGECHOOSER_COMPLETE" ]; then
				# Explanation: we revert back to the
				# locale inherited from the language
				# step if the country step did NOT
				# induce change in language and country
				# but the resulting locale is different
				# from the one we had in first step.
				echo "$old_locale"
			else
				echo "$entry"
			fi
			break
		fi
	done
}


# Reset all variables
LANGUAGE=""
COUNTRY=""
COUTRYNAME=""
LOCALE=""

# debconf/language is an alias for debian-installer/language
db_register "$languagecode" "debconf/language"

# Only display the translated texts (ie the English "translation") when in
# UTF-8 mode. Note: seems the only case this triggers is serial console;
# probably not needed anymore: we already limit which languages we display.
if echo $LANG $LC_CTYPE | grep -q UTF-8; then
	INITIAL_LANGUAGE=en
else
	INITIAL_LANGUAGE=""
fi

# Find the display level and set languages in the template
# Needs to be done before checking preseeding, so we can preseed the
# correct template.
build_language_template $(language_display_level)

# Support preseeding of the locale all in one variable for convenience.
# Only check for preseeding the first time localechooser is run.
country_preseeded=""
if [ ! -f /var/lib/localechooser/preseeded ]; then
	if db_get $localecode && [ "$RET" ]; then
		do_preseed $RET
	fi

	>/var/lib/localechooser/preseeded
fi


# Main loop starts here
# Use a state machine to allow jumping back to previous questions.
# Main states are multiples of 10 to allow "preparation" states to be
# skipped when backing up.
STATE=10
while :; do
	case "$STATE" in
	   10)	# Display language list
		sel_language=1
		# Disabled because of #470258: template is set to true too early
		if false && \
		   db_get debconf/translations-dropped && [ "$RET" = true ]; then
			if db_fget $langname_template seen && [ "$RET" != true ]; then
				sel_language=""
				db_input high localechooser/translation/no-select || true
			fi
		else
			# Set initial language for correct display of list
			set_debconf_language $INITIAL_LANGUAGE

			db_capb backup align
			db_input critical $langlist || [ $? -eq 30 ]
		fi
		;;

	   11)	# We have a language
		db_get $langlist
		LANGUAGE="$RET"

		# Determine defaults based on languagelist
		. languagemap
		db_set "$languagecode" "$LANGUAGELIST"
		log "Set $languagecode = '$LANGUAGELIST'"
		db_set "$localecode"   "$LOCALE"
		log "Set $localecode = '$LOCALE'"
		db_set "$fallbacklocalecode"   "$FALLBACKLOCALE"
		log "Set $fallbacklocalecode = '$FALLBACKLOCALE'"

		if [ -n "$DEFAULT_COUNTRY" ]; then
			log "Default country = '$DEFAULT_COUNTRY'"
		fi

		db_set "$consoledisplay"  "$CONSOLE"
		log "Set $consoledisplay = '$CONSOLE'"

		db_set "debconf/language" "$LANGUAGELIST"
		log "Set debconf/language = '$LANGUAGELIST'"

		[ -f /etc/lsb-release ] && . /etc/lsb-release
		if [ "$sel_language" ] && [ $LANGUAGE != en ] && \
		   [ "$X_INSTALLATION_MEDIUM" = "floppy" ]; then
			db_input high localechooser/translation/none-yet || true
		fi
		;;

	   12)	# Warn if translation is incomplete
		set_debconf_language "$LANGUAGELIST"

		# Display warning for incomplete translations; skip it for
		# automated installs to prevent a loop if the default is false
		twarning=""
		if [ "$sel_language" ] && \
		   db_get debconf/priority && [ "$RET" != critical ] && \
		   tstatus=$(translation-check "$LANGUAGE"); then
			twarning=$(warning_template $tstatus)
			db_input high $twarning || [ $? -eq 30 ]
		fi
		;;

	   13)	# Continue or choose alternative language
		if [ "$twarning" ]; then
			if db_get $twarning && [ "$RET" = false ]; then
				db_reset $twarning
				STATE=10
				continue
			fi
		fi

		install_lang_specific

		STATE=19
		continue
		;;

	   19)	# Prepare for country selection
		# Keep track of values we have after language selection step
		LOCALE_LANGUAGECHOOSER=$LOCALE
		LANGUAGECODE_LANGUAGECHOOSER=$LANGUAGE
		# If present, keep track of charset or modifier we got previously
		EXTRA_LANGUAGECHOOSER=`echo $FALLBACKLOCALE | sed -e 's/^[^.@]*//'`

		FIRST_LANG="${LANGUAGELIST%%:*}"

		# We use /etc/shortlists to check if we should present a shortlist
		# As we may unregister the question for shortlists, the value for the
		# shortlist template is also saved with the language specific question
		use_lang=""
		if [ "$LOCALE" != "C" ]; then
			if grep -q "^$FIRST_LANG" $SHORTLISTS; then
				use_lang=$FIRST_LANG
			elif grep -q "^$LANGUAGE" $SHORTLISTS; then
				use_lang=$LANGUAGE
			fi
		fi

		# At this point we should have either xx, or xx_YY in LOCALE
		allprio=critical
		shortprio=critical
		;;

	   20)	# Display a country shortlist if there is one
		askedshort=
		db_get $countrycode
		current_country="$RET"

		# If the fallback locale does not include a country code
		# (and thus no underscore character), we must prompt for a
		# country and thus display all countries. Example: Esperanto.
		# The next "if" test will be false and "askedshort" remains
		# unset, so no short country list question and continent
		# dialogs are shown at critical priority as we need a country.
		if echo $FALLBACKLOCALE | grep "_" >/dev/null 2>&1; then
			# Otherwise, prompt with the short list for languages
			# that are listed in /etc/shortlists; for others prompt
			# with all continents/countries (at medium priority)
			if [ "$use_lang" ]; then
				shortlist_template="$shortlist-$use_lang"
				db_unregister $shortlist || true
				db_register $shortlist_template $shortlist
				if db_fget $countrycode seen; then
					db_fset $shortlist seen $RET || true
				fi

				# Set default value
				if [ $LASTSTATE -ne 21 ]; then
					current_short=""
					if [ "$current_country" ]; then
						if has_country $shortlist "$current_country"; then
							current_short="$current_country"
						else
							current_short=other
						fi
					elif has_country $shortlist "$DEFAULT_COUNTRY"; then
						current_short="$DEFAULT_COUNTRY"
					fi
					db_set $shortlist "$current_short"
				fi

				# If the current (preseeded) value is not in the
				# shortlist, ask for continent/country instead
				if [ -z "$country_preseeded" ] || \
				   [ "$current_short" != other ]; then
					db_input $shortprio $shortlist || [ $? -eq 30 ]
					askedshort=1
				fi
				country_preseeded=""
			else
				allprio=medium
				# Display continents after backing up from locale
				# selection for countries without shortlist
				if [ $LASTSTATE -gt 21 ]; then
					STATE=21
					continue
				fi
			fi
		fi
		;;

	   21)	# Check if a country was selected from the short list
		# and if not, allow to select a continent
		if [ "$askedshort" ]; then
			db_get $shortlist
			COUNTRYCODE="$RET"
			if [ "$COUNTRYCODE" != "other" ]; then
				STATE=24
				continue
			fi
		fi

		# Set default value
		if [ $LASTSTATE -ne 22 ]; then
			if [ "$current_country" ]; then
				set_default_continent "$current_country"
			else
				set_default_continent "$DEFAULT_COUNTRY"
			fi
		else
			# Backed up; reset continent template if no country
			# was actually selected so it can get a new default
			if [ -z "$current_country" ]; then
				db_reset $tpl_continent
			fi
		fi
		db_input $allprio $continentlist || [ $? -eq 30 ]
		;;

	   22)	# Select a country on the continent
		db_get $continentlist
		tpl_continent="$countrylist/$(echo $RET | sed "s/ /_/g")"
		if db_fget $countrycode seen; then
			db_fset $tpl_continent seen $RET || true
		fi

		if [ "$current_country" ] && \
		   has_country $tpl_continent "$current_country"; then
			db_set $tpl_continent "$current_country"
		elif db_get $tpl_continent && [ -z "$RET" ] && \
		   has_country $tpl_continent "$DEFAULT_COUNTRY"; then
			db_set $tpl_continent "$DEFAULT_COUNTRY"
		fi

		db_input $allprio $tpl_continent || [ $? -eq 30 ]
		;;

	   23)	# Get the selected country
		db_get $tpl_continent
		COUNTRYCODE="$RET"
		;;

	   24)	# We have a country
		db_set "$countrycode"  "$COUNTRYCODE"
		log "Set $countrycode = '$COUNTRYCODE'"

		STATE=29
		continue
		;;

	   29)	# Prepare for locale selection; determine default locale
		# Find a supported locale which best fits the selected language
		# and country.
		# Refinement: we try to use the modifier inherited from language
		# selection. However, we do this only if the locale is valid.

		# Maybe no refinement should be done if locale is preseeded?
		if [ "$LOCALE" != "C" ]; then
			OLDLOCALE=$LOCALE
			LOCALE=""

			LOCALE=$(refine_locale "$OLDLOCALE")

			# Fall back to a supported locale
			if [ -z "$LOCALE" ]; then
				if grep -q "^$FALLBACKLOCALE$" $SUPPORTEDLOCALES; then
					LOCALE="$FALLBACKLOCALE"
				else
					LOCALE=$(echo $FALLBACKLOCALE | sed -e 's/[.@].*$//')
				fi
				log "Falling back to locale '$LOCALE'"
			fi
		fi

		# Set the locale
		db_set "$localecode" "$LOCALE"
		log "Set $localecode = '$LOCALE'"

		# The code below adds lang_COUNTRY at the beginning of the
		# language list we got from languagechooser.
		# We shouldn't just add this before the former list in case
		# the country is changed several times.
		if [ "$COUNTRYCODE" != "$DEFAULT_COUNTRY" ] && \
		   [ "$COUNTRYCODE" ] && [ "$LANGUAGE" ] && \
		   [ "$LOCALE" != "C" ] && [ "$LANGUAGELIST" != "$LANGUAGE" ]; then
			LANGUAGELIST=${LANGUAGE}_${COUNTRYCODE}:$LANGUAGELIST
			db_set "$languagecode" "$LANGUAGELIST"
			log "Set $languagecode = '$LANGUAGELIST'"
		fi
		;;

	   30)	# Select system locale
		# We will select from supported locales for LANGUAGE_COUNTRY
		if [ "$LOCALE" != "C" ]; then
			POSSIBLELOCALES=$(grep -e "^${LANGUAGE}_${COUNTRYCODE}" $SUPPORTEDLOCALES || true)
			if [ -z "$POSSIBLELOCALES" ]; then
				POSSIBLELOCALES=$(grep -e "^${LANGUAGE}_${COUNTRYCODE_LANGUAGECHOOSER}" $SUPPORTEDLOCALES || true)
			fi
			if [ $(echo $POSSIBLELOCALES | wc -w) -gt 1 ]; then
				CHOICES=""
				for i in $POSSIBLELOCALES ; do
					CHOICES="${CHOICES:+$CHOICES, }$i"
				done
				db_subst $localecode LOCALELIST "$CHOICES"
				db_input medium $localecode || [ $? -eq 30 ]
			fi
		fi
		;;

	   31)	# Select additional locales
		db_get $localecode
		LOCALE="$RET"

		CHOICES=
		# *.UTF-8@euro locales are deprecated; don't use them.
		for i in $(grep -v '\.UTF-8@euro$' $SUPPORTEDLOCALES | grep -v "^$LOCALE$"); do
			CHOICES="${CHOICES:+$CHOICES, }$i"
		done
		db_subst $supportedlocales LOCALELIST "$CHOICES"
		db_fget $supportedlocales seen
		if [ "$RET" = false ]; then
			db_set $supportedlocales "$LOCALE"
		fi
		db_input medium $supportedlocales || [ $? -eq 30 ]
		;;

	    *)
		break
		;;
	esac

	LASTSTATE=$STATE
	if db_go; then
		STATE=$(($STATE + 1))
	else
		STATELEVEL=$(($STATE / 10 * 10)) # round down to multiple of 10
		if [ $STATE -eq $STATELEVEL ]; then
			STATE=$(($STATE - 10))
		else
			STATE=$(($STATE - 1))
		fi
	fi
	db_capb backup
done

if [ $STATE -eq 0 ]; then
	exit 10 # back out to main menu
fi

# All locales being UTF-8, unconditionnally set this, for
# console-setup purposes
db_set debian-installer/charmap UTF-8

exit 0
